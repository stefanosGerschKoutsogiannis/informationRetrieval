2017,Masked Autoregressive Flow for Density Estimation,Autoregressive models are among the best performing neural density estimators. We describe an approach for increasing the flexibility of an autoregressive model  based on modelling the random numbers that the model uses internally when generating data. By constructing a stack of autoregressive models  each modelling the random numbers of the next model in the stack  we obtain a type of normalizing flow suitable for density estimation  which we call Masked Autoregressive Flow. This type of flow is closely related to Inverse Autoregressive Flow and is a generalization of Real NVP. Masked Autoregressive Flow achieves state-of-the-art performance in a range of general-purpose density estimation tasks.,Masked Autoregressive Flow for Density Estimation

George Papamakarios
University of Edinburgh

g.papamakarios@ed.ac.uk

Theo Pavlakou

University of Edinburgh

theo.pavlakou@ed.ac.uk

Iain Murray

University of Edinburgh
i.murray@ed.ac.uk

Abstract

Autoregressive models are among the best performing neural density estimators.
We describe an approach for increasing the ﬂexibility of an autoregressive model 
based on modelling the random numbers that the model uses internally when gen-
erating data. By constructing a stack of autoregressive models  each modelling the
random numbers of the next model in the stack  we obtain a type of normalizing
ﬂow suitable for density estimation  which we call Masked Autoregressive Flow.
This type of ﬂow is closely related to Inverse Autoregressive Flow and is a gen-
eralization of Real NVP. Masked Autoregressive Flow achieves state-of-the-art
performance in a range of general-purpose density estimation tasks.

1

Introduction

The joint density p(x) of a set of variables x is a central object of interest in machine learning. Being
able to access and manipulate p(x) enables a wide range of tasks to be performed  such as inference 
prediction  data completion and data generation. As such  the problem of estimating p(x) from a set
of examples {xn} is at the core of probabilistic unsupervised learning and generative modelling.
In recent years  using neural networks for density estimation has been particularly successful. Combin-
ing the ﬂexibility and learning capacity of neural networks with prior knowledge about the structure
of data to be modelled has led to impressive results in modelling natural images [4  30  37  38] and
audio data [34  36]. State-of-the-art neural density estimators have also been used for likelihood-free
inference from simulated data [21  23]  variational inference [13  24]  and as surrogates for maximum
entropy models [19].
Neural density estimators differ from other approaches to generative modelling—such as variational
autoencoders [12  25] and generative adversarial networks [7]—in that they readily provide exact
density evaluations. As such  they are more suitable in applications where the focus is on explicitly
evaluating densities  rather than generating synthetic data. For instance  density estimators can learn
suitable priors for data from large unlabelled datasets  for use in standard Bayesian inference [39].
In simulation-based likelihood-free inference  conditional density estimators can learn models for
the likelihood [5] or the posterior [23] from simulated data. Density estimators can learn effective
proposals for importance sampling [22] or sequential Monte Carlo [8  21]; such proposals can be
used in probabilistic programming environments to speed up inference [15  16]. Finally  conditional
density estimators can be used as ﬂexible inference networks for amortized variational inference and
as part of variational autoencoders [12  25].
A challenge in neural density estimation is to construct models that are ﬂexible enough to represent
complex densities  but have tractable density functions and learning algorithms. There are mainly
two families of neural density estimators that are both ﬂexible and tractable: autoregressive models
[35] and normalizing ﬂows [24]. Autoregressive models decompose the joint density as a product of
conditionals  and model each conditional in turn. Normalizing ﬂows transform a base density (e.g. a
standard Gaussian) into the target density by an invertible transformation with tractable Jacobian.

31st Conference on Neural Information Processing Systems (NIPS 2017)  Long Beach  CA  USA.

Our starting point is the realization (as pointed out by Kingma et al. [13]) that autoregressive models 
when used to generate data  correspond to a differentiable transformation of an external source of
randomness (typically obtained by random number generators). This transformation has a tractable
Jacobian by design  and for certain autoregressive models it is also invertible  hence it precisely
corresponds to a normalizing ﬂow. Viewing an autoregressive model as a normalizing ﬂow opens
the possibility of increasing its ﬂexibility by stacking multiple models of the same type  by having
each model provide the source of randomness for the next model in the stack. The resulting stack of
models is a normalizing ﬂow that is more ﬂexible than the original model  and that remains tractable.
In this paper we present Masked Autoregressive Flow (MAF)  which is a particular implementation of
the above normalizing ﬂow that uses the Masked Autoencoder for Distribution Estimation (MADE)
[6] as a building block. The use of MADE enables density evaluations without the sequential loop
that is typical of autoregressive models  and thus makes MAF fast to evaluate and train on parallel
computing architectures such as Graphics Processing Units (GPUs). We show a close theoretical
connection between MAF and Inverse Autoregressive Flow (IAF) [13]  which has been designed for
variational inference instead of density estimation  and show that both correspond to generalizations
of the successful Real NVP [4]. We experimentally evaluate MAF on a wide range of datasets  and
we demonstrate that (a) MAF outperforms Real NVP on general-purpose density estimation  and (b)
a conditional version of MAF achieves close to state-of-the-art performance on conditional image
modelling even with a general-purpose architecture.

2 Background

2.1 Autoregressive density estimation

one-dimensional conditionals as p(x) =(cid:81)

Using the chain rule of probability  any joint density p(x) can be decomposed into a product of
i p(xi | x1:i−1). Autoregressive density estimators [35]
model each conditional p(xi | x1:i−1) as a parametric density  whose parameters are a function of a
hidden state hi. In recurrent architectures  hi is a function of the previous hidden state hi−1 and the
ith input variable xi. The Real-valued Neural Autoregressive Density Estimator (RNADE) [32] uses
mixtures of Gaussian or Laplace densities for modelling the conditionals  and a simple linear rule for
updating the hidden state. More ﬂexible approaches for updating the hidden state are based on Long
Short-Term Memory recurrent neural networks [30  38].
A drawback of autoregressive models is that they are sensitive to the order of the variables. For
example  the order of the variables matters when learning the density of Figure 1a if we assume a
model with Gaussian conditionals. As Figure 1b shows  a model with order (x1  x2) cannot learn
this density  even though the same model with order (x2  x1) can represent it perfectly. In practice
is it hard to know which of the factorially many orders is the most suitable for the task at hand.
Autoregressive models that are trained to work with an order chosen at random have been developed 
and the predictions from different orders can then be combined in an ensemble [6  33]. Our approach
(Section 3) can use a different order in each layer  and using random orders would also be possible.
Straightforward recurrent autoregressive models would update a hidden state sequentially for every
variable  requiring D sequential computations to compute the probability p(x) of a D-dimensional
vector  which is not well-suited for computation on parallel architectures such as GPUs. One way to
enable parallel computation is to start with a fully-connected model with D inputs and D outputs  and
drop out connections in order to ensure that output i will only be connected to inputs 1  2  . . .   i−1.
Output i can then be interpreted as computing the parameters of the ith conditional p(xi | x1:i−1).
By construction  the resulting model will satisfy the autoregressive property  and at the same time
it will be able to calculate p(x) efﬁciently on a GPU. An example of this approach is the Masked
Autoencoder for Distribution Estimation (MADE) [6]  which drops out connections by multiplying
the weight matrices of a fully-connected autoencoder with binary masks. Other mechanisms for
dropping out connections include masked convolutions [38] and causal convolutions [36].

2.2 Normalizing ﬂows

A normalizing ﬂow [24] represents p(x) as an invertible differentiable transformation f of a base
density πu(u). That is  x = f (u) where u ∼ πu(u). The base density πu(u) is chosen such that it
can be easily evaluated for any input u (a common choice for πu(u) is a standard Gaussian). Under

2

(a) Target density

Figure 1: (a) The density to be learnt  deﬁned as p(x1  x2) = N (x2 | 0  4)N(cid:0)x1 | 1

(b) MADE with Gaussian conditionals

(c) MAF with 5 layers

2  1(cid:1). (b) The

density learnt by a MADE with order (x1  x2) and Gaussian conditionals. Scatter plot shows the train
data transformed into random numbers u; the non-Gaussian distribution indicates that the model is a
poor ﬁt. (c) Learnt density and transformed train data of a 5 layer MAF with the same order (x1  x2).

4 x2

the invertibility assumption for f  the density p(x) can be calculated as

(cid:0)f−1(x)(cid:1)(cid:12)(cid:12)(cid:12)(cid:12)det

(cid:18) ∂f−1

∂x

(cid:19)(cid:12)(cid:12)(cid:12)(cid:12) .

p(x) = πu

(1)

In order for Equation (1) to be tractable  the transformation f must be constructed such that (a) it
is easy to invert  and (b) the determinant of its Jacobian is easy to compute. An important point is
that if transformations f1 and f2 have the above properties  then their composition f1 ◦ f2 also has
these properties. In other words  the transformation f can be made deeper by composing multiple
instances of it  and the result will still be a valid normalizing ﬂow.
There have been various approaches in developing normalizing ﬂows. An early example is Gaussian-
ization [2]  which is based on successive application of independent component analysis. Enforcing
invertibility with nonsingular weight matrices has been proposed [1  26]  however in such approaches
calculating the determinant of the Jacobian scales cubicly with data dimensionality in general. Pla-
nar/radial ﬂows [24] and Inverse Autoregressive Flow (IAF) [13] are models whose Jacobian is
tractable by design. However  they were developed primarily for variational inference and are not
well-suited for density estimation  as they can only efﬁciently calculate the density of their own sam-
ples and not of externally provided datapoints. The Non-linear Independent Components Estimator
(NICE) [3] and its successor Real NVP [4] have a tractable Jacobian and are also suitable for density
estimation. IAF  NICE and Real NVP are discussed in more detail in Section 3.

3 Masked Autoregressive Flow

3.1 Autoregressive models as normalizing ﬂows

Consider an autoregressive model whose conditionals are parameterized as single Gaussians. That is 
the ith conditional is given by

p(xi | x1:i−1) = N(cid:0)xi | µi  (exp αi)2(cid:1) where µi = fµi(x1:i−1) and αi = fαi (x1:i−1).

(2)
In the above  fµi and fαi are unconstrained scalar functions that compute the mean and log standard
deviation of the ith conditional given all previous variables. We can generate data from the above
model using the following recursion:

xi = ui exp αi + µi where µi = fµi(x1:i−1)  αi = fαi(x1:i−1) and ui ∼ N (0  1).

(3)
In the above  u = (u1  u2  . . .   uI ) is the vector of random numbers the model uses internally to
generate data  typically by making calls to a random number generator often called randn().
Equation (3) provides an alternative characterization of the autoregressive model as a transformation
f from the space of random numbers u to the space of data x. That is  we can express the model
as x = f (u) where u ∼ N (0  I). By construction  f is easily invertible. Given a datapoint x  the
random numbers u that were used to generate it are obtained by the following recursion:
ui = (xi − µi) exp(−αi) where µi = fµi(x1:i−1) and αi = fαi(x1:i−1).

(4)

3

Due to the autoregressive structure  the Jacobian of f−1 is triangular by design  hence its absolute
determinant can be easily obtained as follows:

(cid:12)(cid:12)(cid:12)(cid:12)det
(cid:18) ∂f−1

∂x

(cid:19)(cid:12)(cid:12)(cid:12)(cid:12) = exp

(cid:16)−(cid:88)

αi

i

(cid:17)

where αi = fαi(x1:i−1).

(5)

It follows that the autoregressive model can be equivalently interpreted as a normalizing ﬂow  whose
density p(x) can be obtained by substituting Equations (4) and (5) into Equation (1). This observation
was ﬁrst pointed out by Kingma et al. [13].
A useful diagnostic for assessing whether an autoregressive model of the above type ﬁts the target
density well is to transform the train data {xn} into corresponding random numbers {un} using
Equation (4)  and assess whether the ui’s come from independent standard normals. If the ui’s do
not seem to come from independent standard normals  this is evidence that the model is a bad ﬁt. For
instance  Figure 1b shows that the scatter plot of the random numbers associated with the train data
can look signiﬁcantly non-Gaussian if the model ﬁts the target density poorly.
Here we interpret autoregressive models as a ﬂow  and improve the model ﬁt by stacking multiple
instances of the model into a deeper ﬂow. Given autoregressive models M1  M2  . . .   MK  we model
the density of the random numbers u1 of M1 with M2  model the random numbers u2 of M2 with M3
and so on  ﬁnally modelling the random numbers uK of MK with a standard Gaussian. This stacking
adds ﬂexibility: for example  Figure 1c demonstrates that a ﬂow of 5 autoregressive models is able
to learn multimodal conditionals  even though each model has unimodal conditionals. Stacking has
previously been used in a similar way to improve model ﬁt of deep belief nets [9] and deep mixtures
of factor analyzers [28].
We choose to implement the set of functions {fµi  fαi} with masking  following the approach used
by MADE [6]. MADE is a feedforward network that takes x as input and outputs µi and αi for
all i with a single forward pass. The autoregressive property is enforced by multiplying the weight
matrices of MADE with suitably constructed binary masks. In other words  we use MADE with
Gaussian conditionals as the building layer of our ﬂow. The beneﬁt of using masking is that it
enables transforming from data x to random numbers u and thus calculating p(x) in one forward
pass through the ﬂow  thus eliminating the need for sequential recursion as in Equation (4). We call
this implementation of stacking MADEs into a ﬂow Masked Autoregressive Flow (MAF).

3.2 Relationship with Inverse Autoregressive Flow

Like MAF  Inverse Autoregressive Flow (IAF) [13] is a normalizing ﬂow which uses MADE as its
component layer. Each layer of IAF is deﬁned by the following recursion:

xi = ui exp αi + µi where µi = fµi(u1:i−1) and αi = fαi (u1:i−1).

(6)
Similarly to MAF  functions {fµi  fαi} are computed using a MADE with Gaussian conditionals.
The difference is architectural: in MAF µi and αi are directly computed from previous data variables
x1:i−1  whereas in IAF µi and αi are directly computed from previous random numbers u1:i−1.
The consequence of the above is that MAF and IAF are different models with different computational
trade-offs. MAF is capable of calculating the density p(x) of any datapoint x in one pass through
the model  however sampling from it requires performing D sequential passes (where D is the
dimensionality of x). In contrast  IAF can generate samples and calculate their density with one pass 
however calculating the density p(x) of an externally provided datapoint x requires D passes to ﬁnd
the random numbers u associated with x. Hence  the design choice of whether to connect µi and
αi directly to x1:i−1 (obtaining MAF) or to u1:i−1 (obtaining IAF) depends on the intended usage.
IAF is suitable as a recognition model for stochastic variational inference [12  25]  where it only
ever needs to calculate the density of its own samples. In contrast  MAF is more suitable for density
estimation  because each example requires only one pass through the model whereas IAF requires D.
A theoretical equivalence between MAF and IAF is that training a MAF with maximum likelihood
corresponds to ﬁtting an implicit IAF to the base density with stochastic variational inference. Let
πx(x) be the data density we wish to learn  πu(u) be the base density  and f be the transformation
from u to x as implemented by MAF. The density deﬁned by MAF (with added subscript x for
disambiguation) is

(cid:0)f−1(x)(cid:1)(cid:12)(cid:12)(cid:12)(cid:12)det

(cid:18) ∂f−1

∂x

(cid:19)(cid:12)(cid:12)(cid:12)(cid:12) .

px(x) = πu

(7)

4

The inverse transformation f−1 from x to u can be seen as describing an implicit IAF with base
density πx(x)  which deﬁnes the following implicit density over the u space:

(cid:12)(cid:12)(cid:12)(cid:12)det
(cid:18) ∂f
Training MAF by maximizing the total log likelihood(cid:80)

(8)
n log p(xn) on train data {xn} corresponds
to ﬁtting px(x) to πx(x) by stochastically minimizing DKL(πx(x)(cid:107) px(x)). In Section A of the
supplementary material  we show that

(cid:19)(cid:12)(cid:12)(cid:12)(cid:12) .

pu(u) = πx(f (u))

∂u

DKL(πx(x)(cid:107) px(x)) = DKL(pu(u)(cid:107) πu(u)).

(9)
Hence  stochastically minimizing DKL(πx(x)(cid:107) px(x)) is equivalent to ﬁtting pu(u) to πu(u) by
minimizing DKL(pu(u)(cid:107) πu(u)). Since the latter is the loss function used in variational inference 
and pu(u) can be seen as an IAF with base density πx(x) and transformation f−1  it follows that
training MAF as a density estimator of πx(x) is equivalent to performing stochastic variational
inference with an implicit IAF  where the posterior is taken to be the base density πu(u) and the
transformation f−1 implements the reparameterization trick [12  25]. This argument is presented in
more detail in Section A of the supplementary material.

3.3 Relationship with Real NVP

Real NVP [4] (NVP stands for Non Volume Preserving) is a normalizing ﬂow obtained by stacking
coupling layers. A coupling layer is an invertible transformation f from random numbers u to data x
with a tractable Jacobian  deﬁned by

x1:d = u1:d

µ = fµ(u1:d)
α = fα(u1:d).

where

xd+1:D = ud+1:D (cid:12) exp α + µ

(10)
In the above  (cid:12) denotes elementwise multiplication  and the exp is applied to each element of α. The
transformation copies the ﬁrst d elements  and scales and shifts the remaining D−d elements  with
the amount of scaling and shifting being a function of the ﬁrst d elements. When stacking coupling
layers into a ﬂow  the elements are permuted across layers so that a different set of elements is copied
each time. A special case of the coupling layer where α = 0 is used by NICE [3].
We can see that the coupling layer is a special case of both the autoregressive transformation used by
MAF in Equation (3)  and the autoregressive transformation used by IAF in Equation (6). Indeed  we
can recover the coupling layer from the autoregressive transformation of MAF by setting µi = αi = 0
for i ≤ d and making µi and αi functions of only x1:d for i > d (for IAF we need to make µi and αi
functions of u1:d instead for i > d). In other words  both MAF and IAF can be seen as more ﬂexible
(but different) generalizations of Real NVP  where each element is individually scaled and shifted as
a function of all previous elements. The advantage of Real NVP compared to MAF and IAF is that it
can both generate data and estimate densities with one forward pass only  whereas MAF would need
D passes to generate data and IAF would need D passes to estimate densities.

decomposing any conditional density as p(x| y) =(cid:81)

3.4 Conditional MAF
Given a set of example pairs {(xn  yn)}  conditional density estimation is the task of estimating
the conditional density p(x| y). Autoregressive modelling extends naturally to conditional density
estimation. Each term in the chain rule of probability can be conditioned on side-information y 
i p(xi | x1:i−1  y). Therefore  we can turn any
unconditional autoregressive model into a conditional one by augmenting its set of input variables
with y and only modelling the conditionals that correspond to x. Any order of the variables can be
chosen  as long as y comes before x. In masked autoregressive models  no connections need to be
dropped from the y inputs to the rest of the network.
We can implement a conditional version of MAF by stacking MADEs that were made conditional
using the above strategy. That is  in a conditional MAF  the vector y becomes an additional input
for every layer. As a special case of MAF  Real NVP can be made conditional in the same way.
In Section 4  we show that conditional MAF signiﬁcantly outperforms unconditional MAF when
conditional information (such as data labels) is available. In our experiments  MAF was able to
beneﬁt from conditioning considerably more than MADE and Real NVP.

5

4 Experiments

4.1

Implementation and setup

We systematically evaluate three types of density estimator (MADE  Real NVP and MAF) in terms
of density estimation performance on a variety of datasets. Code for reproducing our experiments
(which uses Theano [29]) can be found at https://github.com/gpapamak/maf.
MADE. We consider two versions: (a) a MADE with Gaussian conditionals  denoted simply by
MADE  and (b) a MADE whose conditionals are each parameterized as a mixture of C Gaussians 
denoted by MADE MoG. We used C = 10 in all our experiments. MADE can be seen either as a
MADE MoG with C = 1  or as a MAF with only one autoregressive layer. Adding more Gaussian
components per conditional or stacking MADEs to form a MAF are two alternative ways of increasing
the ﬂexibility of MADE  which we are interested in comparing.
Real NVP. We consider a general-purpose implementation of the coupling layer  which uses two
feedforward neural networks  implementing the scaling function fα and the shifting function fµ
respectively. Both networks have the same architecture  except that fα has hyperbolic tangent hidden
units  whereas fµ has rectiﬁed linear hidden units (we found this combination to perform best). Both
networks have a linear output. We consider Real NVPs with either 5 or 10 coupling layers  denoted
by Real NVP (5) and Real NVP (10) respectively  and in both cases the base density is a standard
Gaussian. Successive coupling layers alternate between (a) copying the odd-indexed variables and
transforming the even-indexed variables  and (b) copying the even-indexed variables and transforming
the odd-indexed variables. It is important to clarify that this is a general-purpose implementation of
Real NVP which is different and thus not comparable to its original version [4]  which was designed
speciﬁcally for image data. Here we are interested in comparing coupling layers with autoregressive
layers as building blocks of normalizing ﬂows for general-purpose density estimation tasks  and our
design of Real NVP is such that a fair comparison between the two can be made.
MAF. We consider three versions: (a) a MAF with 5 autoregressive layers and a standard Gaussian as
a base density πu(u)  denoted by MAF (5)  (b) a MAF with 10 autoregressive layers and a standard
Gaussian as a base density  denoted by MAF (10)  and (c) a MAF with 5 autoregressive layers and a
MADE MoG with C = 10 Gaussian components as a base density  denoted by MAF MoG (5). MAF
MoG (5) can be thought of as a MAF (5) stacked on top of a MADE MoG and trained jointly with it.
In all experiments  MADE and MADE MoG order the inputs using the order that comes with the
dataset by default; no alternative orders were considered. MAF uses the default order for the ﬁrst
autoregressive layer (i.e. the layer that directly models the data) and reverses the order for each
successive layer (the same was done for IAF by Kingma et al. [13]).
MADE  MADE MoG and each layer in MAF is a feedforward neural network with masked weight
matrices  such that the autoregressive property holds. The procedure for designing the masks (due to
Germain et al. [6]) is as follows. Each input or hidden unit is assigned a degree  which is an integer
ranging from 1 to D  where D is the data dimensionality. The degree of an input is taken to be its
index in the order. The D outputs have degrees that sequentially range from 0 to D−1. A unit is
allowed to receive input only from units with lower or equal degree  which enforces the autoregressive
property. In order for output i to be connected to all inputs with degree less than i  and thus make
sure that no conditional independences are introduced  it is both necessary and sufﬁcient that every
hidden layer contains every degree. In all experiments except for CIFAR-10  we sequentially assign
degrees within each hidden layer and use enough hidden units to make sure that all degrees appear.
Because CIFAR-10 is high-dimensional  we used fewer hidden units than inputs and assigned degrees
to hidden units uniformly at random (as was done by Germain et al. [6]).
We added batch normalization [10] after each coupling layer in Real NVP and after each autore-
gressive layer in MAF. Batch normalization is an elementwise scaling and shifting  which is easily
invertible and has a tractable Jacobian  and thus it is suitable for use in a normalizing ﬂow. We
found that batch normalization in Real NVP and MAF reduces training time  increases stability
during training and improves performance (as observed by Dinh et al. [4] for Real NVP). Section B
of the supplementary material discusses our implementation of batch normalization and its use in
normalizing ﬂows.
All models were trained with the Adam optimizer [11]  using a minibatch size of 100  and a step size
of 10−3 for MADE and MADE MoG  and of 10−4 for Real NVP and MAF. A small amount of (cid:96)2

6

Table 1: Average test log likelihood (in nats) for unconditional density estimation. The best performing
model for each dataset is shown in bold (multiple models are highlighted if the difference is not
statistically signiﬁcant according to a paired t-test). Error bars correspond to 2 standard deviations.

POWER

GAS

HEPMASS

BSDS300
MINIBOONE
−7.74 ± 0.02 −3.58 ± 0.75 −27.93 ± 0.02 −37.24 ± 1.07
96.67 ± 0.25
Gaussian
3.56 ± 0.04 −20.98 ± 0.02 −15.59 ± 0.50
−3.08 ± 0.03
148.85 ± 0.28
MADE
8.47 ± 0.02 −15.15 ± 0.02 −12.27 ± 0.47
153.71 ± 0.28
0.40 ± 0.01
MADE MoG
Real NVP (5) −0.02 ± 0.01
4.78 ± 1.80 −19.62 ± 0.02 −13.55 ± 0.49
152.97 ± 0.28
8.33 ± 0.14 −18.71 ± 0.02 −13.84 ± 0.52
153.28 ± 1.78
0.17 ± 0.01
Real NVP (10)
9.07 ± 0.02 −17.70 ± 0.02 −11.75 ± 0.44
0.14 ± 0.01
155.69 ± 0.28
MAF (5)
0.24 ± 0.01 10.08 ± 0.02 −17.73 ± 0.02 −12.24 ± 0.45
154.93 ± 0.28
MAF (10)
9.59 ± 0.02 −17.39 ± 0.02 −11.68 ± 0.44 156.36 ± 0.28
0.30 ± 0.01
MAF MoG (5)

regularization was added  with coefﬁcient 10−6. Each model was trained with early stopping until no
improvement occurred for 30 consecutive epochs on the validation set. For each model  we selected
the number of hidden layers and number of hidden units based on validation performance (we gave
the same options to all models)  as described in Section D of the supplementary material.

4.2 Unconditional density estimation

Following Uria et al. [32]  we perform unconditional density estimation on four UCI datasets
(POWER  GAS  HEPMASS  MINIBOONE) and on a dataset of natural image patches (BSDS300).
UCI datasets. These datasets were taken from the UCI machine learning repository [18]. We selected
different datasets than Uria et al. [32]  because the ones they used were much smaller  resulting in
an expensive cross-validation procedure involving a separate hyperparameter search for each fold.
However  our data preprocessing follows Uria et al. [32]. The sample mean was subtracted from the
data and each feature was divided by its sample standard deviation. Discrete-valued attributes were
eliminated  as well as every attribute with a Pearson correlation coefﬁcient greater than 0.98. These
procedures are meant to avoid trivial high densities  which would make the comparison between
approaches hard to interpret. Section D of the supplementary material gives more details about the
UCI datasets and the individual preprocessing done on each of them.
Image patches. This dataset was obtained by extracting random 8×8 monochrome patches from
the BSDS300 dataset of natural images [20]. We used the same preprocessing as by Uria et al. [32].
Uniform noise was added to dequantize pixel values  which was then rescaled to be in the range [0  1].
The mean pixel value was subtracted from each patch  and the bottom-right pixel was discarded.
Table 1 shows the performance of each model on each dataset. A Gaussian ﬁtted to the train data is
reported as a baseline. We can see that on 3 out of 5 datasets MAF is the best performing model  with
MADE MoG being the best performing model on the other 2. On all datasets  MAF outperforms
Real NVP. For the MINIBOONE dataset  due to overlapping error bars  a pairwise comparison was
done to determine which model performs the best  the results of which are reported in Section E
of the supplementary material. MAF MoG (5) achieves the best reported result on BSDS300 for a
single model with 156.36 nats  followed by Deep RNADE [33] with 155.2. An ensemble of 32 Deep
RNADEs was reported to achieve 157.0 nats [33]. The UCI datasets were used for the ﬁrst time in
the literature for density estimation  so no comparison with existing work can be made yet.

4.3 Conditional density estimation

For conditional density estimation  we used the MNIST dataset of handwritten digits [17] and the
CIFAR-10 dataset of natural images [14]. In both datasets  each datapoint comes from one of 10
distinct classes. We represent the class label as a 10-dimensional  one-hot encoded vector y  and we
model the density p(x| y)  where x represents an image. At test time  we evaluate the probability of
10 is a uniform prior over the labels. For
comparison  we also train every model as an unconditional density estimator and report both results.

a test image x by p(x) =(cid:80)

y p(x| y)p(y)  where p(y) = 1

7

Table 2: Average test log likelihood (in nats) for conditional density estimation. The best performing
model for each dataset is shown in bold. Error bars correspond to 2 standard deviations.

MNIST

CIFAR-10

unconditional
−1366.9 ± 1.4
−1380.8 ± 4.8
−1038.5 ± 1.8
−1323.2 ± 6.6
−1370.7 ± 10.1
−1300.5 ± 1.7
−1313.1 ± 2.0
−1100.3 ± 1.6

conditional
−1344.7 ± 1.8
−1361.9 ± 1.9
−1030.3 ± 1.7
−1326.3 ± 5.8
−1371.3 ± 43.9
−591.7 ± 1.7
−605.6 ± 1.8
−1092.3 ± 1.7

unconditional
2367 ± 29
147 ± 20
−397 ± 21
2576 ± 27
2568 ± 26
2936 ± 27
3049 ± 26
2911 ± 26

conditional
2030 ± 41
187 ± 20
−119 ± 20
2642 ± 26
2475 ± 25
5797 ± 26
5872 ± 26
2936 ± 26

Gaussian
MADE
MADE MoG
Real NVP (5)
Real NVP (10)
MAF (5)
MAF (10)
MAF MoG (5)

For both MNIST and CIFAR-10  we use the same preprocessing as by Dinh et al. [4]. We dequantize
pixel values by adding uniform noise  and then rescale them to [0  1]. We transform the rescaled pixel
values into logit space by x (cid:55)→ logit(λ + (1 − 2λ)x)  where λ = 10−6 for MNIST and λ = 0.05 for
CIFAR-10  and perform density estimation in that space. In the case of CIFAR-10  we also augment
the train set with horizontal ﬂips of all train examples (as also done by Dinh et al. [4]).
Table 2 shows the results on MNIST and CIFAR-10. The performance of a class-conditional Gaussian
is reported as a baseline for the conditional case. Log likelihoods are calculated in logit space. For
unconditional density estimation  MADE MoG is the best performing model on MNIST  whereas
MAF is the best performing model on CIFAR-10. For conditional density estimation  MAF is by far
the best performing model on both datasets. On CIFAR-10  both MADE and MADE MoG performed
signiﬁcantly worse than the Gaussian baseline. MAF outperforms Real NVP in all cases.
The conditional performance of MAF is particularly impressive. MAF performs almost twice as well
compared to its unconditional version and to every other model’s conditional version. To facilitate
comparison with the literature  Section E of the supplementary material reports results in bits/pixel.
MAF (5) and MAF (10)  the two best performing conditional models  achieve 3.02 and 2.98 bits/pixel
respectively on CIFAR-10. This result is very close to the state-of-the-art 2.94 bits/pixel achieved
by a conditional PixelCNN++ [27]  even though  unlike PixelCNN++  our version of MAF does not
incorporate prior image knowledge  and it pays a price for doing density estimation in a transformed
real-valued space (PixelCNN++ directly models discrete pixel values).

5 Discussion

We showed that we can improve MADE by modelling the density of its internal random numbers.
Alternatively  MADE can be improved by increasing the ﬂexibility of its conditionals. The comparison
between MAF and MADE MoG showed that the best approach is dataset speciﬁc; in our experiments
MAF outperformed MADE MoG in 6 out of 9 cases  which is strong evidence of its competitiveness.
MADE MoG is a universal density approximator; with sufﬁciently many hidden units and Gaussian
components  it can approximate any continuous density arbitrarily well. It is an open question
whether MAF with a Gaussian base density has a similar property (MAF MoG clearly does).
We also showed that the coupling layer used in Real NVP is a special case of the autoregressive layer
used in MAF. In fact  MAF outperformed Real NVP in all our experiments. Real NVP has achieved
impressive performance in image modelling by incorporating knowledge about image structure. Our
results suggest that replacing coupling layers with autoregressive layers in the original version of Real
NVP is a promising direction for further improving its performance. Real NVP maintains however
the advantage over MAF (and autoregressive models in general) that samples from the model can be
generated efﬁciently in parallel.
MAF achieved impressive results in conditional density estimation. Whereas almost all models we
considered beneﬁted from the additional information supplied by the labels  MAF nearly doubled
its performance  coming close to state-of-the-art models for image modelling without incorporating

8

any prior image knowledge. The ability of MAF to beneﬁt signiﬁcantly from conditional knowledge
suggests that automatic discovery of conditional structure (e.g. ﬁnding labels by clustering) could be
a promising direction for improving unconditional density estimation in general.
Density estimation is one of several types of generative modelling  with the focus on obtaining
accurate densities. However  we know that accurate densities do not necessarily imply good perfor-
mance in other tasks  such as in data generation [31]. Alternative approaches to generative modelling
include variational autoencoders [12  25]  which are capable of efﬁcient inference of their (potentially
interpretable) latent space  and generative adversarial networks [7]  which are capable of high quality
data generation. Choice of method should be informed by whether the application at hand calls for
accurate densities  latent space inference or high quality samples. Masked Autoregressive Flow is a
contribution towards the ﬁrst of these goals.

Acknowledgments

We thank Maria Gorinova for useful comments. George Papamakarios and Theo Pavlakou were sup-
ported by the Centre for Doctoral Training in Data Science  funded by EPSRC (grant EP/L016427/1)
and the University of Edinburgh. George Papamakarios was also supported by Microsoft Research
through its PhD Scholarship Programme.

References
[1] J. Ballé  V. Laparra  and E. P. Simoncelli. Density modeling of images using a generalized normalization

transformation. Proceedings of the 4nd International Conference on Learning Representations  2016.

[2] S. S. Chen and R. A. Gopinath. Gaussianization. Advances in Neural Information Processing Systems 13 

pages 423–429  2001.

[3] L. Dinh  D. Krueger  and Y. Bengio. NICE: Non-linear Independent Components Estimation.

arXiv:1410.8516  2014.

[4] L. Dinh  J. Sohl-Dickstein  and S. Bengio. Density estimation using Real NVP. Proceedings of the 5th

International Conference on Learning Representations  2017.

[5] Y. Fan  D. J. Nott  and S. A. Sisson. Approximate Bayesian computation via regression density estimation.

Stat  2(1):34–48  2013.

[6] M. Germain  K. Gregor  I. Murray  and H. Larochelle. MADE: Masked Autoencoder for Distribution
Estimation. Proceedings of the 32nd International Conference on Machine Learning  pages 881–889 
2015.

[7] I. Goodfellow  J. Pouget-Abadie  M. Mirza  B. Xu  D. Warde-Farley  S. Ozair  A. Courville  and Y. Bengio.
Generative adversarial nets. Advances in Neural Information Processing Systems 27  pages 2672–2680 
2014.

[8] S. Gu  Z. Ghahramani  and R. E. Turner. Neural adaptive sequential Monte Carlo. Advances in Neural

Information Processing Systems 28  pages 2629–2637  2015.

[9] G. Hinton  S. Osindero  and Y.-W. Teh. A fast learning algorithm for deep belief nets. Neural Computation 

18(7):1527–1554  2006.

[10] S. Ioffe and C. Szegedy. Batch normalization: Accelerating deep network training by reducing internal
covariate shift. Proceedings of the 32nd International Conference on Machine Learning  pages 448–456 
2015.

[11] D. P. Kingma and J. Ba. Adam: A method for stochastic optimization. Proceedings of the 3rd International

Conference on Learning Representations  2015.

[12] D. P. Kingma and M. Welling. Auto-encoding variational Bayes. Proceedings of the 2nd International

Conference on Learning Representations  2014.

[13] D. P. Kingma  T. Salimans  R. Jozefowicz  X. Chen  I. Sutskever  and M. Welling. Improved variational
inference with Inverse Autoregressive Flow. Advances in Neural Information Processing Systems 29  pages
4743–4751  2016.

[14] A. Krizhevsky and G. Hinton. Learning multiple layers of features from tiny images. Technical report 

University of Toronto  2009.

[15] T. D. Kulkarni  P. Kohli  J. B. Tenenbaum  and V. Mansinghka. Picture: A probabilistic programming
language for scene perception. IEEE Conference on Computer Vision and Pattern Recognition  pages
4390–4399  2015.

9

[16] T. A. Le  A. G. Baydin  and F. Wood. Inference compilation and universal probabilistic programming.

Proceedings of the 20th International Conference on Artiﬁcial Intelligence and Statistics  2017.

[17] Y. LeCun  C. Cortes  and C. J. C. Burges. The MNIST database of handwritten digits. URL http:

//yann.lecun.com/exdb/mnist/.

[18] M. Lichman. UCI machine learning repository  2013. URL http://archive.ics.uci.edu/ml.
[19] G. Loaiza-Ganem  Y. Gao  and J. P. Cunningham. Maximum entropy ﬂow networks. Proceedings of the

5th International Conference on Learning Representations  2017.

[20] D. Martin  C. Fowlkes  D. Tal  and J. Malik. A database of human segmented natural images and its
application to evaluating segmentation algorithms and measuring ecological statistics. pages 416–423 
2001.

[21] B. Paige and F. Wood. Inference networks for sequential Monte Carlo in graphical models. Proceedings of

the 33rd International Conference on Machine Learning  2016.

[22] G. Papamakarios and I. Murray. Distilling intractable generative models  2015. Probabilistic Integration

Workshop at Neural Information Processing Systems 28.

[23] G. Papamakarios and I. Murray. Fast -free inference of simulation models with Bayesian conditional

density estimation. Advances in Neural Information Processing Systems 29  2016.

[24] D. J. Rezende and S. Mohamed. Variational inference with normalizing ﬂows. Proceedings of the 32nd

International Conference on Machine Learning  pages 1530–1538  2015.

[25] D. J. Rezende  S. Mohamed  and D. Wierstra. Stochastic backpropagation and approximate inference in
deep generative models. Proceedings of the 31st International Conference on Machine Learning  pages
1278–1286  2014.

[26] O. Rippel and R. P. Adams. High-dimensional probability estimation with deep density models.

arXiv:1302.5125  2013.

[27] T. Salimans  A. Karpathy  X. Chen  and D. P. Kingma. PixelCNN++: Improving the PixelCNN with

discretized logistic mixture likelihood and other modiﬁcations. arXiv:1701.05517  2017.

[28] Y. Tang  R. Salakhutdinov  and G. Hinton. Deep mixtures of factor analysers. Proceedings of the 29th

International Conference on Machine Learning  pages 505–512  2012.

[29] Theano Development Team. Theano: A Python framework for fast computation of mathematical expres-

sions. arXiv:1605.02688  2016.

[30] L. Theis and M. Bethge. Generative image modeling using spatial LSTMs. Advances in Neural Information

Processing Systems 28  pages 1927–1935  2015.

[31] L. Theis  A. van den Oord  and M. Bethge. A note on the evaluation of generative models. Proceedings of

the 4nd International Conference on Learning Representations  2016.

[32] B. Uria  I. Murray  and H. Larochelle. RNADE: The real-valued neural autoregressive density-estimator.

Advances in Neural Information Processing Systems 26  pages 2175–2183  2013.

[33] B. Uria  I. Murray  and H. Larochelle. A deep and tractable density estimator. Proceedings of the 31st

International Conference on Machine Learning  pages 467–475  2014.

[34] B. Uria  I. Murray  S. Renals  C. Valentini-Botinhao  and J. Bridle. Modelling acoustic feature dependencies
with artiﬁcial neural networks: Trajectory-RNADE. IEEE International Conference on Acoustics  Speech
and Signal Processing  pages 4465–4469  2015.

[35] B. Uria  M.-A. Côté  K. Gregor  I. Murray  and H. Larochelle. Neural autoregressive distribution estimation.

Journal of Machine Learning Research  17(205):1–37  2016.

[36] A. van den Oord  S. Dieleman  H. Zen  K. Simonyan  O. Vinyals  A. Graves  N. Kalchbrenner  A. W.

Senior  and K. Kavukcuoglu. WaveNet: A generative model for raw audio. arXiv:1609.03499  2016.

[37] A. van den Oord  N. Kalchbrenner  L. Espeholt  K. Kavukcuoglu  O. Vinyals  and A. Graves. Conditional
image generation with PixelCNN decoders. Advances in Neural Information Processing Systems 29  pages
4790–4798  2016.

[38] A. van den Oord  N. Kalchbrenner  and K. Kavukcuoglu. Pixel recurrent neural networks. Proceedings of

the 33rd International Conference on Machine Learning  pages 1747–1756  2016.

[39] D. Zoran and Y. Weiss. From learning models of natural image patches to whole image restoration.

Proceedings of the 13rd International Conference on Computer Vision  pages 479–486  2011.

10

,Yu Xin
Tommi Jaakkola
Kevin Winner
Daniel Sheldon
George Papamakarios
Theo Pavlakou
Iain Murray
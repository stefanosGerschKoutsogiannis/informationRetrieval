2019,Knowledge Extraction with No Observable Data,Knowledge distillation is to transfer the knowledge of a large neural network into a smaller one and has been shown to be effective especially when the amount of training data is limited or the size of the student model is very small. To transfer the knowledge  it is essential to observe the data that have been used to train the network since its knowledge is concentrated on a narrow manifold rather than the whole input space. However  the data are not accessible in many cases due to the privacy or confidentiality issues in medical  industrial  and military domains. To the best of our knowledge  there has been no approach that distills the knowledge of a neural network when no data are observable. In this work  we propose KegNet (Knowledge Extraction with Generative Networks)  a novel approach to extract the knowledge of a trained deep neural network and to generate artificial data points that replace the missing training data in knowledge distillation. Experiments show that KegNet outperforms all baselines for data-free knowledge distillation. We provide the source code of our paper in https://github.com/snudatalab/KegNet.,Knowledge Extraction with No Observable Data

Jaemin Yoo

Seoul National University
jaeminyoo@snu.ac.kr

Taebum Kim

Seoul National University
k.taebum@snu.ac.kr

Minyong Cho

Seoul National University
chominyong@gmail.com

U Kangâˆ—

Seoul National University

ukang@snu.ac.kr

Abstract

Knowledge distillation is to transfer the knowledge of a large neural network into
a smaller one and has been shown to be effective especially when the amount of
training data is limited or the size of the student model is very small. To transfer
the knowledge  it is essential to observe the data that have been used to train the
network since its knowledge is concentrated on a narrow manifold rather than the
whole input space. However  the data are not accessible in many cases due to the
privacy or conï¬dentiality issues in medical  industrial  and military domains. To the
best of our knowledge  there has been no approach that distills the knowledge of a
neural network when no data are observable. In this work  we propose KEGNET
(Knowledge Extraction with Generative Networks)  a novel approach to extract the
knowledge of a trained deep neural network and to generate artiï¬cial data points
that replace the missing training data in knowledge distillation. Experiments show
that KEGNET outperforms all baselines for data-free knowledge distillation. We
provide the source code of our paper in https://github.com/snudatalab/KegNet.

1

Introduction

How can we distill the knowledge of a deep neural network without any observable data?
Knowledge distillation [9] is to transfer the knowledge of a large neural network or an ensemble of
neural networks into a smaller network. Given a set of trained teacher models  one feeds training
data to them and uses their predictions instead of the true labels to train the small student model. It
has been effective especially when the amount of training data is limited or the size of the student
model is very small [14  28]  because the teacherâ€™s knowledge helps the student to learn efï¬ciently
the hidden relationships between the target labels even with a small dataset.
However  it is essential for knowledge distillation that at least a few training examples are observable 
since the knowledge of a deep neural network does not cover the whole input space; it is focused
on a manifold px of data that the network has actually observed. The network is likely to produce
unpredictable outputs if given random inputs that are not described by px  misguiding the student
network. There are recent works for distilling a networkâ€™s knowledge by a small dataset [22] or only
metadata at each layer [23]  but no approach has successfully distilled the knowledge without any
observable data. It is desirable in this case to generate artiï¬cial data by generative networks [7  31] 
but they also require a large amount of training data to estimate the true manifold px.
We propose KEGNET (Knowledge Extraction with Generative Networks)  a novel architecture that
extracts the knowledge of a trained neural network for knowledge distillation without observable data.

âˆ—Corresponding author.

33rd Conference on Neural Information Processing Systems (NeurIPS 2019)  Vancouver  Canada.

Figure 1: An overall structure of KEGNET. The generator creates artiï¬cial data and feed them into
the classiï¬er and decoder. The ï¬xed classiï¬er produces the label distribution of each data point  and
the decoder ï¬nds its hidden representation as a low-dimensional vector.

KEGNET estimates the data manifold px by generating artiï¬cial data points  based on the conditional
distribution p(y|x) of label y which has been learned by the given neural network. The generated
examples replace the missing training data when distilling the knowledge of the given network. As a
result  the knowledge is transferred well to other networks even with no observable data.
The overall structure of KEGNET is depicted in Figure 1  which consists of two learnable networks G
and D. A trained network M is given as a teacher  and we aim to distill its knowledge to a student
network which is not included in this ï¬gure. The ï¬rst learnable network is a generator G that takes a
pair of sampled variables Ë†y and Ë†z to create a fake data point Ë†x. The second network is a decoder D
which aims to extract the variable Ë†z from Ë†x  given as an input for Ë†x. The variable Ë†z is interpreted as a
low-dimensional representation of Ë†x  which contains the implicit meaning of Ë†x independently from
the label Ë†y. The networks G and D are updated to minimize the reconstruction errors between the
input and output variables: Ë†y and Â¯y  and Ë†z and Â¯z. After the training  G is used to generate fake data
which replace the missing training data in the distillation; D is not used in this step.
Our extensive experiments in Section 5 show that KEGNET accurately extracts the knowledge of a
trained deep neural network for various types of datasets. KEGNET outperforms baseline methods
for distilling the knowledge without observable data  showing a large improvement of accuracy up to
39.6 percent points compared with the best competitors. Especially  KEGNET generates artiï¬cial
data whose patterns are clearly recognizable by extracting the knowledge of well-known classiï¬ers
such as a residual network [8] trained with image datasets such as MNIST [21] and SVHN [25].

2 Related Work

2.1 Knowledge Distillation

Knowledge distillation [9] is a technique to transfer the knowledge of a large neural network or an
ensemble of neural networks into a small one. Given a teacher network M and a student network S 
we feed training data to M and use its predictions to train S instead of the true labels. As a result  S
is trained by soft distributions rather than one-hot vectors  learning latent relationships between the
labels that M has already learned. Knowledge distillation has been used for reducing the size of a
model or training a model with insufï¬cient data [1  2  12  14  29].
Recent works focused on the distillation with insufï¬cient data. Papernot et al. [28] and Kimura et al.
[15] used knowledge distillation to effectively use unlabeled data for semi-supervised learning when
a trained teacher network is given. Li et al. [22] added a 1 Ã— 1 convolutional layer at the end of each
block of a student network and aligned the teacher and student networks by updating those layers
when only a few samples are given. Lopes et al. [23] considered the case where the data were not
observable  but metadata were given for each activation layer of the teacher network. From the given
metadata  they reconstructed the missing data and used them to train a student network.

2

Noise ğ‘§Ì‚Label ğ‘¦$Generated datağ‘¥$Generator ğºğ‘ğ‘¥ğ‘¦ ğ‘§Classifier ğ‘€(fixed)Decoder ğ·ğ‘ğ‘§ğ‘¥Label ğ‘¦+Noise ğ‘§Ì…Classifier lossDecoder lossğ‘Ì‚-ğ‘¦ğ‘.ğ‘§concatsamplingsamplingHowever  these approaches assume that at least a few labeled examples or metadata are given so that
it is able to estimate the distribution of missing data. They are not applicable to situations where no
data are accessible due to strict privacy or conï¬dentiality. To the best of our knowledge  there has
been no approach that works well without training data in knowledge distillation  despite its large
importance in various domains that impose strict limitations for distributing the data.

2.2 Tucker Decomposition

A tensor decomposition is to represent an n-dimensional tensor as a sequence of small tensors. Tucker
decomposition [13  30] is one of the most successful algorithms for a tensor decomposition  which
decomposes an n-dimensional tensor X âˆˆ RI1Ã—I2Ã—Â·Â·Â·Ã—In into the following form:

Ë†X = G Ã—1 A(1) Ã—2 A(2) Ã—3 Â·Â·Â· Ã—N A(N ) 

(1)
where Ã—i is the i-mode product [16] between a tensor and a matrix  G âˆˆ RR1Ã—R2Ã—Â·Â·Â·Ã—Rn is a core
tensor  and A(i) âˆˆ RIiÃ—Ri is the i-th factor matrix.
Tucker decomposition has been used to compress various types of deep neural networks. Kim et al.
[13] and Kholiavchenko [11] compressed convolutional neural networks using Tucker-2 decomposi-
tion which decomposes convolution kernels along the ï¬rst two axes (the numbers of ï¬lters and input
channels). They used the global analytic variational Bayesian matrix factorization (VBMF) [24] for
selecting the rank R  which is important to the performance of compression. Kossaiï¬ et al. [17] used
Tucker decomposition to compress fully connected layers as well as convolutional layers.
Unlike most compression algorithms [3  4]  Tucker decomposition itself is a data-free algorithm that
requires no training data in the execution. However  a ï¬ne-tuning of the compressed networks has
been essential [11  13] since the compression is done layerwise and the compressed layers are not
aligned with respect to the target problem. In this work  we use Tucker decomposition to initialize a
student network that requires the teacherâ€™s knowledge to improve its performance. Our work can be
seen as using Tucker decomposition as a general compression algorithm when the target network is
given but no data are observable  and can be extended to other compression algorithms.

3 Knowledge Extraction

We are given a trained network M that predicts the label of a feature vector x as a probability vector.
However  we have no information about the data distribution px(x) that was used to train M  which
is essential to understand its functionality and to use its learned knowledge in further tasks. It is thus
desirable to estimate px(x) from M  which is the opposite of a traditional learning problem that aims
to train M based on observable px. We call this knowledge extraction.
However  it is impracticable to estimate px(x) directly since the data space R|x| is exponential with
the dimensionality of data  while we have no single observation except the trained classiï¬er M. We
thus revert to sampling data points and modeling an empirical distribution: for a set D of sampled
points  the probability of each sampled point is 1/|D|  and the probability at any other point is zero.
We generate the set D of sampled data points by modeling a conditional probability of x given two
random vectors y and z  where y is a probability vector that represents a label  and z is our proposed
variable that represents the implicit meaning of a data point as a low-dimensional vector:

D =

p(Ë†x|Ë†y  Ë†z) | Ë†y âˆ¼ Ë†py(y) and Ë†z âˆ¼ pz(z)

arg max

Ë†x

 

(2)

where Ë†py(y) is an estimation of the true label distribution py(y) which we cannot observe  and pz(z)
is our proposed distribution that is assumed to describe the property of z.
In this way  we reformulate the problem as to estimate the conditional distribution p(x|y  z) instead
of the data distribution px(x). Recall that z is a low-dimensional representation of a data point x.
The variables y and z are conditionally independent of each other given x  since they both depend on
x but have no direct interactions. Thus  the argmax in Equation (2) is rewritten as follows:

p(Ë†x|Ë†y  Ë†z) = arg max

arg max

Ë†x

Ë†x

= arg max

Ë†x

(log p(Ë†y|Ë†x  Ë†z) + log p(Ë†x|Ë†z) âˆ’ log p(Ë†y|Ë†z))
(log p(Ë†y|Ë†x) + log p(Ë†x|Ë†z)) 

(3)

(4)

(cid:26)

(cid:27)

3

where the ï¬rst probability p(Ë†y|Ë†x) is the direct output of M when Ë†x is given as an input  which we do
not need to estimate since M is already trained. The second probability p(Ë†x|Ë†z) represents how well Ë†z
represents the property of Ë†x as its low-dimensional representation.
However  estimating the distribution p(x|z) requires knowing px(x) in advance  which we cannot
observe due to the absence of accessible data. Thus  we rewrite Equation (4) as Equation (5) and then
approximate it as Equation (6) ignoring the data probability px(x):

p(Ë†x|Ë†y  Ë†z) = arg max
â‰ˆ arg max

Ë†x

(log p(Ë†y|Ë†x) + log p(Ë†z|Ë†x) + log p(Ë†x) âˆ’ log p(Ë†z))
(log p(Ë†y|Ë†x) + log p(Ë†z|Ë†x)).

(6)
The difference is that now we estimate the likelihood p(Ë†z|Ë†x) of the variable Ë†z given Ë†x instead of the
posterior p(Ë†x|Ë†z). Equation (6) is our ï¬nal target of estimation for extracting the knowledge of the
given model M. We introduce in the next section how to model these conditional distributions by
deep neural networks and how to design an objective function which we aim to minimize.

Ë†x

arg max

Ë†x

(5)

4 Proposed Method

KEGNET (Knowledge Extraction with Generative Networks) is our novel architecture to distill the
knowledge of a neural network without using training data  by extracting its knowledge as a set of
artiï¬cial data points of Equation (2). KEGNET uses two kinds of deep neural networks to model the
conditional distributions in Equation (6). The ï¬rst is a generator G which takes Ë†y and Ë†z as inputs and
returns a data point with the maximum conditional likelihood p(Ë†x|Ë†y  Ë†z). The second is a decoder D
which takes a data point Ë†x as an input and returns its low-dimensional representation Â¯z.
The overall structure of KEGNET is depicted in Figure 1. The generator G is our main component
that estimates the empirical distribution by sampling a data point Ë†x several times. Given a sampled
class vector Ë†y as an input  G is trained to produce data points that M is likely to classify as Ë†y. This
makes G learn different properties of different classes based on M  but leads it to generate similar
data points for each class. To address this problem  we train G also to minimize the reconstruction
error between Ë†z and Â¯z  forcing G to embed the information of Ë†z in the generated data Ë†x so that D can
successfully recover it. Thus  data points of the same class should be different from each other when
given different input variables Ë†z. The reconstruction errors are computed for Ë†y and Ë†z  respectively 
and then added to the ï¬nal objective function. We also introduce a diversity loss to further increase
the data diversity in each batch so that the generated data cover a larger region in the data space.

4.1 Objective Function

We formulate the conditional probabilities of Equation (6) as loss terms to train both the generator G
and decoder D  and combine them as a single objective function:

l(B) =

lcls(Ë†y  Ë†z) + Î±ldec(Ë†y  Ë†z)

+ Î²ldiv(B) 

(7)

(cid:17)

(cid:88)

(cid:16)

(Ë†y Ë†z)âˆˆB

which consists of three different loss functions lcls  ldec  and ldiv. B is a batch of sampled variables
{(Ë†y  Ë†z) | Ë†y âˆ¼ Ë†py(y)  Ë†z âˆ¼ pz(z)}  and Î± and Î² are two nonnegative hyperparameters that adjust the
balance between the loss terms. Each batch is created by sampling Ë†y and Ë†z randomly several times
from the distributions Ë†py and pz which are determined also as hyperparameters. In our experiments 
we set Ë†py to the categorical distribution that produces one-hot vectors as Ë†y  and pz to the multivariate
Gaussian distribution that produces standard normal vectors.
The classiï¬er loss lcls in Equation (8) represents the distance between the input label Ë†y given to G and
the output M (G(Ë†y  Ë†z)) returned from M as the cross-entropy between two probability distributions.
Note that Ë†y is not a scalar label but a probability vector of length |S| where S is the set of classes.
Minimizing lcls forces the generated data to follow a manifold that M is able to classify well. The
learned manifold may be different from px  but is suited for extracting the knowledge of M.

lcls(Ë†y  Ë†z) = âˆ’(cid:80)

iâˆˆS Ë†yi log M (G(Ë†y  Ë†z))i

(8)

The decoder loss ldec in Equation (9) represents the distance between the input variable Ë†z given to
G and the output D(G(Ë†y  Ë†z)) returned from D. We use the Euclidean distance instead of the cross

4

entropy since z is not a probability distribution. If we optimize G only for lcls  it is likely to produce
similar data points for each class with little diversity. ldec prevents such a problem by forcing G to
include the information of Ë†z along with Ë†y in the generated data.
ldec(Ë†y  Ë†z) = (cid:107)Ë†z âˆ’ D(G(Ë†y  Ë†z))(cid:107)2
2.

(9)

However  the diversity of generated data points may still be insufï¬cient even though D forces G to
include the information of Ë†z in Ë†x. In such a case  the empirical distribution estimated by G covers
only a small manifold in the large data space  extracting only partial knowledge of M. The diversity
loss ldiv is introduced to address the problem and further increase the diversity of generated data.
Given a distance function d between two data points  the diversity loss ldiv is deï¬ned as follows:

ldiv(B) = exp

(Ë†y2 Ë†z2)âˆˆB (cid:107)Ë†z1 âˆ’ Ë†z2(cid:107)2

2 Â· d(G(Ë†y1  Ë†z1)  G(Ë†y2  Ë†z2))

(10)
It increases the pairwise distance between sampled data points in each batch B  multiplied with the
distance between Ë†z1 and Ë†z2. This gives more weights to the pairs of data points whose input variables
are more distant by multiplying the distance of noise variables as a scalar weight. The exponential
function makes ldiv produce a positive value as a loss to be minimized. We set d to the Manhattan
distance function d(x1  x2) = (cid:107)x1 âˆ’ x2(cid:107)1 in our experiments.

.

(cid:16)âˆ’(cid:80)

(Ë†y1 Ë†z1)âˆˆB(cid:80)

(cid:17)

4.2 Relations to Other Structures

Autoencoders The overall structure of KEGNET can be understood as an autoencoder that tries to
reconstruct two variables y and z at the same time. It is speciï¬cally an overcomplete autoencoder
which learns a larger embedding vector than the target variables  since x is a learned representation
and y and z are target variables by this interpretation. It is typically difï¬cult to train an overcomplete
autoencoder because it can recover the target variable in the representation and make a zero recon-
struction error. However in our case  the trained classiï¬er M prevents such a problem because it acts
as a strong regularizer over the generated representations by classifying their labels based on its ï¬xed
knowledge. Thus  G needs to be trained carefully so that the generated representations ï¬t as correct
inputs to M  while containing the information of both y and z.

Generative adversarial networks KEGNET is similar to generated adversarial networks (GAN)
[7] in that a generator creates fake data to estimate the true distribution  and the generated data are
fed into another network to be evaluated. The structure of G is also motivated by DCGAN [31] and
ACGAN [26] for generating image datasets. However  the main difference from GAN-based models
is that we have no observable data and thus we cannot train a discriminator which separates fake data
from the real ones. We instead rely on the trained classiï¬er M and guide G indirectly toward the true
distribution. The decoder D in KEGNET can be understood as an adversarial model that hinders G
from converging to a naive solution  but it is not a direct counterpart of G. Thus  KEGNET can be
understood as a novel architecture designed for the case where no observable data are available.

4.3 Knowledge Distillation

To distill the knowledge of M  we use the trained generator G to create artiï¬cial data and feed them
into both the teacher M and student S. We apply the following two ideas to make S explore a large
space and to maximize its generalization performance. First  we use a set G of multiple generators
instead of a single network. Since each generator is initialized randomly  each of the generators learns
a data manifold that is different from those of the others. The number of generators is not limited
because they do not require observable training data. Second  we set Ë†py to the elementwise uniform
distribution which generates unnormalized probability vectors: Ë†yi âˆ¼ U(0  1) for each i. This gives an
uncertain evidence to G and forces it to generate data points which are not classiï¬ed easily by M 
making M produce soft distributions in which its knowledge is embedded well.
As a result  our loss function ldis to train S by knowledge distillation is given as follows:

ldis(Ë†y  Ë†z) =

CE(M (G(Ë†y  Ë†z))  S(G(Ë†y  Ë†z))) 

(11)

(cid:88)

GâˆˆG

where CE denotes the cross entropy. Previous works for knowledge distillation use a temperature [9]
to increase the entropy of predictions from M so that S can learn hidden relationships between the
classes more easily. We do not use the temperature since the predictions of M are soft already due to
our second idea of using the elementwise uniform distribution as Ë†py.

5

Table 1: Detailed information of datasets.

Dataset
8
Shuttle
16
PenDigits
16
Letter
1 Ã— 28 Ã— 28
MNIST
Fashion MNIST 1 Ã— 28 Ã— 28
3 Ã— 32 Ã— 32
SVHN

Features Labels Training Valid.
5 438
937
2 000
5 000
5 000
5 000

7
10
26
10
10
10

38 062
6 557
14 000
55 000
55 000
68 257

Test Properties

14 500 Unstructured
3 498 Unstructured
4 000 Unstructured
10 000 Grayscale images
10 000 Grayscale images
26 032 RGB images

Table 2: Classiï¬cation accuracy of KEGNET and the baseline methods on the unstructured datasets.
We report the compression ratios of student models along with the accuracy of Tucker.

Model Approach
MLP
MLP
MLP
MLP
MLP

Original
Tucker (T)
T+Uniform
T+Gaussian
T+KEGNET

Pendigits
96.56%
26.44% (8.07Ã—)

Letter
Shuttle
95.63%
99.83%
75.49% (8.17Ã—)
31.40% (4.13Ã—)
93.83 Â± 0.13% 80.21 Â± 0.98% 62.50 Â± 0.90%
94.00 Â± 0.06% 78.22 Â± 1.74% 76.80 Â± 1.84%
94.21 Â± 0.03% 82.62 Â± 1.05% 77.73 Â± 0.33%

5 Experiments

We evaluate KEGNET on two kinds of networks and datasets: multilayer perceptrons on unstructured
datasets from the UCI Machine Learning Repository2  and convolutional neural networks on MNIST
[21]  Fashion MNIST [33]  and SVHN [25]. The datasets are summarized as Table 1.
We compare KEGNET with baseline approaches for distilling the knowledge of a neural network
without using observable data. The simplest approach is to use Tucker decomposition alone  but the
resulting student is not optimized for the target problem because its objective is only to minimize
the reconstruction error. The second approach is to ï¬ne-tune the student after Tucker decomposition
using artiï¬cial data derived from a sampling distribution. If the distribution is largely different from
the true distribution  this approach may even decrease the performance of the student from the ï¬rst
approach. We use the Gaussian distribution N (0  1) and uniform distribution U(âˆ’1  1).
In each setting  we train ï¬ve generators with different random seeds as G and combine the generated
data from all generators. We also train ï¬ve student networks and report the average and standard
deviation of classiï¬cation accuracy for quantitative evaluation. We initialize the compressed weights
of student networks by running the singular value decomposition on the original weights and update
them by Tucker decomposition to minimize the reconstruction errors [18]. We also use the hidden
variable Ë†z of length 10 in all settings  which is much smaller than the data vectors. We use a decoder
network of the same structure in all settings: a multilayer perceptron of n hidden layers with the ELU
activation [5] and batch normalization. n is chosen by the data complexity: n = 1 in MNIST  n = 2
in the unstructured datasets  and n = 3 in Fashion MNIST and SVHN.

5.1 Unstructured Datasets

We use unstructured datasets in the UCI Machine Learning Repository  for which previous works
[6  27] have established reliable standards of performances. We select three datasets which have at
least three classes and ten thousand instances. We divide each dataset into training  validation  and
test sets with the 7:1:2 ratios if the explicit training and test sets are not given. Otherwise  we divide
the given training data into new training and validation sets.
We use a multilayer perceptron (MLP) as a classiï¬er M  which has been used in [27] and contains
ten hidden layers with the ELU activation function and dropout [32] of probability 0.15. We create
student networks by applying Tucker decomposition to all dense layers: the target rank is 5 in Shuttle
and 10 in the others. We use an MLP as a generator G of two hidden layers with the ELU activation

2http://persoal.citius.usc.es/manuel.fernandez.delgado/papers/jmlr/

6

Table 3: Classiï¬cation accuracy of KEGNET and the baselines on the image datasets. We report the
compression ratios of student models along with the accuracy of Tucker. We use three variants of
students for each dataset with different compression ratios.

Dataset Model
LeNet5
MNIST
LeNet5
MNIST
LeNet5
MNIST
MNIST
LeNet5
LeNet5
MNIST

Approach
Original
Tucker (T)
T+Uniform
T+Gaussian
T+KEGNET

SVHN
SVHN
SVHN
SVHN
SVHN

ResNet14 Original
ResNet14 Tucker (T)
ResNet14 T+Uniform
ResNet14 T+Gaussian
ResNet14 T+KEGNET

Fashion ResNet14 Original
Fashion ResNet14 Tucker (T)
Fashion ResNet14 T+Uniform
Fashion ResNet14 T+Gaussian
Fashion ResNet14 T+KEGNET

Student 2
98.90%
67.35% (4.10Ã—)

93.23%
11.02% (1.65Ã—)

Student 3
Student 1
98.90%
98.90%
85.18% (3.62Ã—)
50.01% (4.49Ã—)
95.48 Â± 0.11% 88.27 Â± 0.07% 69.89 Â± 0.28%
95.45 Â± 0.15% 87.70 Â± 0.12% 71.76 Â± 0.18%
96.32 Â± 0.05% 90.89 Â± 0.11% 89.94 Â± 0.08%
93.23%
93.23%
19.31% (1.44Ã—)
11.07% (3.36Ã—)
33.08 Â± 1.47% 63.08 Â± 1.77% 23.83 Â± 1.86%
26.58 Â± 1.61% 60.22 Â± 4.17% 21.49 Â± 2.96%
69.89 Â± 1.24% 87.26 Â± 0.46% 63.40 Â± 1.80%
92.50%
65.09% (1.40Ã—)
< 65.09%
< 65.09%
85.23 Â± 1.36% 87.80 Â± 0.31% 79.95 Â± 1.36%

92.50%
75.80% (1.58Ã—)
< 75.80%
< 75.80%

92.50%
46.55% (2.90Ã—)
< 46.55%
< 46.55%

and batch normalization. We also apply the non-learnable batch normalization after the output layer
to restrict the output space to the standard normal distribution: the parameters Î³ and Î² [10] are ï¬xed
as 0 and 1  respectively. This is natural since most neural networks take standardized inputs.
Table 2 compares the classiï¬cation accuracy of student networks trained by KEGNET and the baseline
approaches on the unstructured datasets. All three approaches show large improvements of accuracy
over Tucker  which applies Tucker decomposition without ï¬ne-tuning. This implies that even simple
distributions are helpful to improve the performance of student networks when no training data are
observable. Nevertheless  KEGNET shows the highest accuracy in all datasets.

5.2

Image Datasets

We use two well-known classiï¬ers on the image datasets: LeNet5 [20] for MNIST and ResNet with
14 layers (referred to as ResNet14) [8] for Fashion MNIST and SVHN. We initialize the student
networks by compressing the weight tensors using Tucker-2 decomposition [13] with VBMF [24];
we compress only the convolutional layers except the dense layers as [13]. Since the classiï¬ers are
convolutional neural networks that are optimized for image datasets  we use a generator that is similar
to that of ACGAN [26]  which consists of two fully connected layers followed by three transposed
convolutional layers with the batch normalization after each layer.

5.2.1 Quantitative Analysis

We evaluate KEGNET by training three different student networks for each classiï¬er. For LeNet5  we
compress the last convolutional layer in Student 1 and the last two convolutional layers in Student 2.
We then increase the compression ratio of Student 2 by decreasing the projection rank in Student 3.
For ResNet14  we compress the last residual block which consists of two convolutional layers. We
compress each of the convolutional layers in Students 1 and 2 and the both layers in Student 3.
Table 3 shows the classiï¬cation accuracy of student networks trained by KEGNET and the baseline
approaches. In MNIST where the dataset and classiï¬er are both simple  the Uniform and Gaussian
baselines also achieve high accuracy which is up to 21.8%p higher than that of Tucker. However 
their accuracy gain becomes much lower in SVHN  and the accuracy becomes even lower than that
of Tucker in Fashion MNIST  meaning that ï¬ne-tuning after Tucker decomposition is not helpful at
all. This shows that simple random distributions fail with complex datasets whose manifolds are
far from trivial distributions. We do not report their exact accuracy in Fashion because they keep

7

(a) MNIST (z = 0).

(b) SVHN (z = 0).

(c) SVHN (averaged by z).

(d) Latent space walking from 0 to 5 in SVHN.

Figure 2: Artiï¬cial images generated by ï¬ve generators of KEGNET for MNIST and SVHN. We ï¬x
the noise variable z to a zero vector in (a) and (b)  while we average multiple images with random z
in (c) and (d). The digits are blurry but recognizable especially when averaged by z.

decreasing as we continue the training. On the other hand  KEGNET outperforms all baselines by
learning successfully the data distributions from the given classiï¬ers in all datasets.

5.2.2 Qualitative Analysis

We also analyze qualitatively the extracted data for the image datasets. Figure 2 visualizes artiï¬cial
images for MNIST and SVHN  which were generated by the ï¬ve generators in G. The images seem
noisy but contain digits which are clearly recognizable  even though the generators do not have any
information about the true datasets. KEGNET generates more clear images in SVHN than in MNIST 
because the digits in SVHN have more distinct patterns than in the hand-written digits. The digits
are more clear when averaged from multiple hidden variables  implying that images with different
hidden variables are diverse but share a common feature that the classiï¬er is able to capture. We also
visualize images with soft evidence in Figure 2d by changing smoothly the input label from 0 to 5. It
is shown that the generators create digits following the strength of evidence for each class.

6 Conclusion

We propose KEGNET (Knowledge Extraction with Generative Networks)  a novel architecture that
extracts the knowledge of a trained neural network without any observable data. KEGNET learns the
conditional distribution of data points by training the generator and decoder networks  and estimates
the manifold of missing data as a set of artiï¬cial data points. Our experiments show that KEGNET is
able to reconstruct unobservable data that were used to train a deep neural network  especially for
image datasets that have distinct and complex manifolds  and improves the performance of data-free
knowledge distillation. Future works include extending KEGNET to knowledge distillation between
neural networks of different structures  such as LeNet5 and ResNet14  or to more complex datasets
such as CIFAR-10/100 [19] that may require a careful design of new generator networks.

Acknowledgments

This work was supported by the ICT R&D program of MSIT/IITP (No.2017-0-01772  Development
of QA systems for Video Story Understanding to pass the Video Turing Test).

8

0123456789ğº"ğº#ğº$ğº%ğº&0123456789ğº"ğº#ğº$ğº%ğº&0123456789ğº"ğº#ğº$ğº%ğº&05ğº"ğº#ğº$ğº%ğº&References
[1] Anoop Korattikara Balan  Vivek Rathod  Kevin P. Murphy  and Max Welling. Bayesian dark

knowledge. In NIPS  2015.

[2] Tianqi Chen  Ian J. Goodfellow  and Jonathon Shlens. Net2net: Accelerating learning via

knowledge transfer. In ICLR  2016.

[3] Jian Cheng  Peisong Wang  Gang Li  Qinghao Hu  and Hanqing Lu. Recent advances in efï¬cient
computation of deep convolutional neural networks. Frontiers of IT & EE  19(1):64â€“77  2018.
[4] Yu Cheng  Duo Wang  Pan Zhou  and Tao Zhang. A survey of model compression and

acceleration for deep neural networks. arXiv  2017.

[5] Djork-ArnÃ© Clevert  Thomas Unterthiner  and Sepp Hochreiter. Fast and accurate deep network

learning by exponential linear units (elus). In ICLR  2016.

[6] Manuel FernÃ¡ndez Delgado  Eva Cernadas  SenÃ©n Barro  and Dinani Gomes Amorim. Do we
need hundreds of classiï¬ers to solve real world classiï¬cation problems? Journal of Machine
Learning Research  15(1):3133â€“3181  2014.

[7] Ian J. Goodfellow  Jean Pouget-Abadie  Mehdi Mirza  Bing Xu  David Warde-Farley  Sherjil

Ozair  Aaron C. Courville  and Yoshua Bengio. Generative adversarial nets. In NIPS  2014.

[8] Kaiming He  Xiangyu Zhang  Shaoqing Ren  and Jian Sun. Deep residual learning for image

recognition. In CVPR  pages 770â€“778  2016.

[9] Geoffrey E. Hinton  Oriol Vinyals  and Jeffrey Dean. Distilling the knowledge in a neural

network. arXiv  2015.

[10] Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training

by reducing internal covariate shift. In ICML  pages 448â€“456  2015.

[11] Maksym Kholiavchenko. Iterative low-rank approximation for CNN compression. arXiv  2018.

URL http://arxiv.org/abs/1803.08995.

[12] Jangho Kim  Seonguk Park  and Nojun Kwak. Paraphrasing complex network: Network

compression via factor transfer. In NeurIPS  2018.

[13] Yong-Deok Kim  Eunhyeok Park  Sungjoo Yoo  Taelim Choi  Lu Yang  and Dongjun Shin.
Compression of deep convolutional neural networks for fast and low power mobile applications.
ICLR  2016.

[14] Yoon Kim and Alexander M. Rush. Sequence-level knowledge distillation. In EMNLP  pages

1317â€“1327  2016.

[15] Akisato Kimura  Zoubin Ghahramani  Koh Takeuchi  Tomoharu Iwata  and Naonori Ueda.
Few-shot learning of neural networks from scratch by pseudo example optimization. In BMVC 
page 105  2018.

[16] Tamara G. Kolda and Brett W. Bader. Tensor decompositions and applications. SIAM Review 

51(3):455â€“500  2009.

[17] Jean Kossaiï¬  Zachary C. Lipton  Aran Khanna  Tommaso Furlanello  and Anima Anandkumar.

Tensor regression networks. arXiv  2017.

[18] Jean Kossaiï¬  Yannis Panagakis  Anima Anandkumar  and Maja Pantic. Tensorly: Tensor

learning in python. Journal of Machine Learning Research  20:26:1â€“26:6  2019.

[19] Alex Krizhevsky  Geoffrey Hinton  et al. Learning multiple layers of features from tiny images.

Technical report  Citeseer  2009.

[20] Yann LeCun  LD Jackel  LÃ©on Bottou  Corinna Cortes  John S Denker  Harris Drucker  Isabelle
Guyon  Urs A Muller  Eduard Sackinger  Patrice Simard  et al. Learning algorithms for
classiï¬cation: A comparison on handwritten digit recognition. Neural networks: the statistical
mechanics perspective  261:276  1995.

[21] Yann LeCun  LÃ©on Bottou  Yoshua Bengio  and Patrick Haffner. Gradient-based learning

applied to document recognition. Proceedings of the IEEE  86(11):2278â€“2324  1998.

[22] Tianhong Li  Jianguo Li  Zhuang Liu  and Changshui Zhang. Knowledge distillation from few

samples. arXiv  2018.

9

[23] Raphael Gontijo Lopes  Stefano Fenu  and Thad Starner. Data-free knowledge distillation for

deep neural networks. NIPS Workshop  2017.

[24] Shinichi Nakajima  Masashi Sugiyama  S. Derin Babacan  and Ryota Tomioka. Global ana-
lytic solution of fully-observed variational bayesian matrix factorization. Journal of Machine
Learning Research  14(1):1â€“37  2013.

[25] Yuval Netzer  Tao Wang  Adam Coates  Alessandro Bissacco  Bo Wu  and Andrew Y Ng.

Reading digits in natural images with unsupervised feature learning. 2011.

[26] Augustus Odena  Christopher Olah  and Jonathon Shlens. Conditional image synthesis with

auxiliary classiï¬er gans. In ICML  2017.

[27] Matthew Olson  Abraham J. Wyner  and Richard Berk. Modern neural networks generalize on

small data sets. In NeurIPS  2018.

[28] Nicolas Papernot  MartÃ­n Abadi  Ãšlfar Erlingsson  Ian J. Goodfellow  and Kunal Talwar. Semi-

supervised knowledge transfer for deep learning from private training data. ICLR  2017.

[29] Antonio Polino  Razvan Pascanu  and Dan Alistarh. Model compression via distillation and

quantization. In ICLR  2018.

[30] Stephan Rabanser  Oleksandr Shchur  and Stephan GÃ¼nnemann. Introduction to tensor decom-

positions and their applications in machine learning. arXiv  2017.

[31] Alec Radford  Luke Metz  and Soumith Chintala. Unsupervised representation learning with

deep convolutional generative adversarial networks. In ICLR  2016.

[32] Nitish Srivastava  Geoffrey E. Hinton  Alex Krizhevsky  Ilya Sutskever  and Ruslan Salakhutdi-
nov. Dropout: a simple way to prevent neural networks from overï¬tting. Journal of Machine
Learning Research  15(1):1929â€“1958  2014.

[33] Han Xiao  Kashif Rasul  and Roland Vollgraf. Fashion-mnist: a novel image dataset for

benchmarking machine learning algorithms  2017.

10

,Dan Rosenbaum
Yair Weiss
Jaemin Yoo
Minyong Cho
Taebum Kim
U Kang
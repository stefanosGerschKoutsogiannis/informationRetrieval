2019,muSSP: Efficient Min-cost Flow Algorithm for Multi-object Tracking,Min-cost flow has been a widely used paradigm for solving data association problems in multi-object tracking (MOT). However  most existing methods of solving min-cost flow problems in MOT are either direct adoption or slight modifications of generic min-cost flow algorithms  yielding sub-optimal computation efficiency and holding the applications back from larger scale of problems. In this paper  by exploiting the special structures and properties of the graphs formulated in MOT problems  we develop an efficient min-cost flow algorithm  namely  minimum-update Successive Shortest Path (muSSP). muSSP is proved to provide exact optimal solution and we demonstrated its efficiency through 40 experiments on five MOT datasets with various object detection results and a number of graph designs. muSSP is always the most efficient in each experiment compared to the three peer solvers  improving the efficiency by 5 to 337 folds relative to the best competing algorithm and averagely 109 to 4089 folds to each of the three peer methods.,muSSP: EfÔ¨Åcient Min-cost Flow Algorithm for

Multi-object Tracking

Congchao Wang  Yizhi Wang  Yinxue Wang  Chiung-Ting Wu  Guoqiang Yu*

Department of Electrical and Computer Engineering  Virginia Tech
{ccwang  yzwang  yxwang90  ctwu  yug}@vt.edu

Abstract

Min-cost Ô¨Çow has been a widely used paradigm for solving data association prob-
lems in multi-object tracking (MOT). However  most existing methods of solving
min-cost Ô¨Çow problems in MOT are either direct adoption or slight modiÔ¨Åcations
of generic min-cost Ô¨Çow algorithms  yielding sub-optimal computation efÔ¨Åciency
and holding the applications back from larger scale of problems. In this paper  by
exploiting the special structures and properties of the graphs formulated in MOT
problems  we develop an efÔ¨Åcient min-cost Ô¨Çow algorithm  namely  minimum-
update Successive Shortest Path (muSSP). muSSP is proved to provide exact
optimal solution and we demonstrated its efÔ¨Åciency through 40 experiments on Ô¨Åve
MOT datasets with various object detection results and a number of graph designs.
muSSP is always the most efÔ¨Åcient in each experiment compared to the three peer
solvers  improving the efÔ¨Åciency by 5 to 337 folds relative to the best competing
algorithm and averagely 109 to 4089 folds to each of the three peer methods.

1

Introduction

Multi-object tracking (MOT) is a fundamental task in computer vision and has a wide range of
applications from trafÔ¨Åc surveillance  self-driving cars to cell/particle tracking in microscopy images
[7  20  15]. In recent years  the min-cost Ô¨Çow formulation of MOT has enjoyed popularity and served
as a workhorse in addressing MOT problems [21  16  4  14  13]. On the one hand  it is a result of the
substantial improvement of object detectors which enables the tracking-by-detection strategy [20  13].
On the other hand  this formulation has great Ô¨Çexibility  for example  it can automatically determine
the number of trajectories and deal with missing or spurious detections [15  4]. Since the min-cost
Ô¨Çow problems have been well studied and there exist polynomial-time algorithms [1]  it was natural
to directly apply the existing algorithms or modify them slightly. Indeed  Zhang et al. [21] used the
cost-scaling approach and Pirsiavash et al. [16] proposed to adopt the successive shortest path (SSP)
approach. These approaches can guarantee global optimality and are widely considered as the most
efÔ¨Åcient solvers for generic min-cost Ô¨Çow problems. However  their efÔ¨Åciency is suboptimal by a
large margin for the MOT problems [14] as conÔ¨Årmed in our experiments.
With the ever increasing number of objects and duration of tracking  more efÔ¨Åcient algorithms for
solving MOT min-cost Ô¨Çow problems are in urgent need. In this paper  we identify several important
special structures and properties of the graph in the MOT min-cost Ô¨Çow problem and show that they
can be used to design efÔ¨Åcient algorithms  resulting in a dramatic reduction of computation time.
SpeciÔ¨Åcally  the graph in a min-cost Ô¨Çow problem for MOT has the following four specialties: (1)
It is a directed acyclic graph (DAG) with single source node s and single sink node t. (2) All arcs‚Äô
capacities are one. (3) Each detection is represented with a pair of nodes  a pre-node and a post-node 
with a transition arc between them to incorporate detection conÔ¨Ådence. (4) For each detection  the
pre-node is linked from s through an inward arc and the post-node is linked to t through an outward
arc. Such arcs allow every detection to be the start or the end of a trajectory. An example of a typical
min-cost Ô¨Çow graph generated from MOT problem is shown in Fig. 1(b).

33rd Conference on Neural Information Processing Systems (NeurIPS 2019)  Vancouver  Canada.

Figure 1: (a) Objects detected in three frames. The Ô¨Årst frame has two detections and misses one.
Lines between detections are possible ways of linking them. Each line is associated with a cost.
Detections 1  3 and 6 should be linked together as a single trajectory. (b) Typical min-cost Ô¨Çow model
for MOT problem. Detection i is represented by a pair of nodes: a pre-node oi and a post-node hi.
The source node s is linked to all pre-nodes and all post-nodes are linked to the sink node t. These
edges are shown in dashed lines. Edges between detections are shown in blue.

Taking advantage of the specialties  we designed the minimum-update successive shortest path
(muSSP) algorithm  an efÔ¨Åcient solver for the min-cost Ô¨Çow in MOT problem. While inspired by SSP
algorithm [1  16]  muSSP made fundamental changes to its framework by leveraging the observation
that  in SSP  most updates in building the shortest path tree through Dijkstra‚Äôs algorithm were wasted
(actually only the shortest s-t paths were useful for Ô¨Ånding the min-cost Ô¨Çow). As detailed in the
method section and Fig. 2 and 3  muSSP consists of four strategies which were guided by theoretical
analysis of the graph properties. muSSP follows the philosophy of minimally updating the shortest
path tree  only when it is necessary to identify the shortest s-t path.
More speciÔ¨Åcally  Ô¨Årstly  if the cost of linking two detections is too high  we can always have a better
association where they are in different trajectories  so these arcs can be safely deleted (specialty 3
and 4). Secondly  it can be proved from specialty 1 and 2 that once an arc connected to either s or
t becomes non-empty  the Ô¨Çow in it will always be 1. Pruning these arcs decreases the graph size
and  more importantly  makes the following search of s-t shortest paths much more efÔ¨Åcient. Thirdly 
specialty 1 and 4 enable us to simultaneously augment multiple shortest s-t paths. Lastly  since we
only have one source and all edges have unit capacity (specialty 1 and 2)  the nodes to be reviewed
for Ô¨Ånding shortest s-t path can be quickly targeted and form a special tree structure. Dijkstra‚Äôs
algorithm can be modiÔ¨Åed to leverage this structure  which dramatically decreases the computation.
It appears that muSSP belongs to the solvers of a dynamic single-source shortest path (dSSSP)
problem [17  10  18]. dSSSP aims to efÔ¨Åciently retrieve the shortest path of each reachable node from
the single source node  after the original graph being modiÔ¨Åed. dSSSP was directly applied to MOT
by one of our peer methods  FollowMe [14]. However  our problem is different from the generic
dSSSP problem because dSSSP tries to re-build the whole shortest path tree  while we care only the
shortest s-t path. A large amount of computation is wasted on updating those unrelated vertices.
muSSP has the same theoretical worst-case complexity as SSP  but brings dramatic efÔ¨Åciency boost in
real applications. The effectiveness of muSSP is evidenced by forty experiments on Ô¨Åve MOT datasets
combined with three widely used graph design methods [16  14  19]. Because min-cost Ô¨Çow was also
frequently used as a sub-routine to approximate the quadratic programming formulation for MOT
problems [13  4]  our experiments include both these two kinds of scenarios. Compared with three
peer algorithms  SSP  FollowMe [14]  and a well-known implementation of cost-scaling algorithm
cs2 [12]  muSSP is always the most efÔ¨Åcient in all experiments  with an efÔ¨Åciency improvement
ranging from 5 to 337 folds relative to the best competing algorithm. Regarding to each individual
algorithm  muSSP is averagely 4089 times faster than SSP  1590 times faster than FollowMe  and
109 times faster than cs2. These improvements are achieved without sacriÔ¨Åcing the space efÔ¨Åciency.

2 Problem Formulation

The problem of associating detections from all frames (data association) can be formulated as a
unit capacity min-cost Ô¨Çow problem on a DAG [21  2] as in Fig.1. In this paper  the term "object"
represents a physical object existing over time (e.g. a person)  and "detection" indicates a detected
snapshot of an object at some time point. An object corresponds to a series (trajectory) of detections.

2

7867864534532121tsùëúÔøΩ‚ÑéÔøΩCostforinclusionCostforlinking258647ùê∂ùëúùë†ùë°(3 6)Frame1Frame2Frame331CostforlinkingMissed(b)(a)We denote the graph built in min-cost Ô¨Çow formulation of MOT as G(V  E  C)  with node set V   arc
set E  and real-valued arc cost function C. The graph has one source s and one sink t. For each
detection i  we create a pre-node oi and a post-node hi  and three arcs  (oi  hi)  (s  oi) and (hi  t).
Any possible spatiotemporal transition of an object is corresponding to some pair of detections  i and
j (i before j in time)  and an arc (hi  oj) is created for it. The capacity of any arc is 1. Any directed
path between node u and node v on graph G is denoted as œÄG(u  v). Under such construction  we can
interpret each s-t path œÄG(s  t) as an object trajectory candidate  linking a sequence of detections.
The problem is then turned into selecting a set of object trajectories from all the candidates. In the
min-cost Ô¨Çow formulation  this is done by sending Ô¨Çow from s to t  and the s-t paths eventually
with Ô¨Çow inside are selected. Due to unit capacities and the total unimodularity of the problem  the
capacity constraints can be reduced to fuv ‚àà {0  1} ‚àÄ(u  v) ‚àà E. The set of arc Ô¨Çows is denoted by
f = {fuv|(u  v) ‚àà E}. We ask for in-out balance at any v ‚àà V \ {s  t} (conservation constraints) 
so a Ô¨Çow with total integer amount K can only be sent through K distinctive s-t paths  reÔ¨Çecting the
assumption of non-overlapping object trajectories.
The selection of s-t paths is guided by the design of arc cost C. MOT looks for object trajectories
with stronger evidences of detection  smaller change of a single object across time  and stronger
evidences of initial and terminate points. Accordingly  the arc cost C(oi  hi) reÔ¨Çects the reward of
including the detection i. C(hi  oj) encodes the similarity between detection i and j. C(s  oi) and
C(hi  t) represent respectively how likely the detection i is the initial point or the terminate point of a
(u v)‚ààE C(u  v)fuv is optimal
uv in arc (u  v) ‚àà E). The costs can be negative  and therefore min-cost
and denoted by f‚àó (with f‚àó
Ô¨Çow formulation automatically leads to the optimal amount of Ô¨Çow when minimizing Cf low(f ).
This min-cost Ô¨Çow problem can also be formulated in an integer linear programming form:

trajectory. The Ô¨Çow f with the minimum overall cost Cf low(f ) =(cid:80)

min

(u v)‚ààEC(u  v)fuv

(1)

(cid:80)
v:(v u)‚ààEfvu =(cid:80)

f

and (cid:80)

s.t. fuv ‚àà {0  1}  for all (u  v) ‚àà E

(2)
(3)
which is guaranteed to have global optimal solution [1]. In the rest of this paper  the term "graph"
and symbol G(V  E  C) all represent the graph built in min-cost Ô¨Çow formulation of MOT problem 
and all discussions are speciÔ¨Åcally for this family of graphs. Besides  the terms node and vertex  edge
and arc  shortest path and least-cost path will be used interchangeably.

v:(u v)‚ààEfuv  for all u ‚àà V \ {s  t} 

3 Method

muSSP uses four major strategies that take advantage of the special properties of our problem (Fig. 2).
We will detail each strategy after giving an overview of the framework. Proofs for lemmas/theorems
as well as the time/space complexity analysis can be found in the supplementary.

3.1 Overall framework

We Ô¨Årst deÔ¨Åne residual graphs used by min-cost Ô¨Çow solvers before we give an overview of muSSP.
DeÔ¨Ånition 1. The residual graph Gr(V  Er  Cr) of G(V  E  C) with respect to a Ô¨Çow f is generated
by replacing each arc (u  v) ‚àà E by two residual arcs (u  v) ‚àà Er and (v  u) ‚àà Er  where
(u  v) ‚àà Er has cost Cr(u  v) = C(u  v) and residual capacity ruv = 1 ‚àí fuv  while (v  u) ‚àà Er
has cost Cr(v  u) = ‚àíC(u  v) and rvu = fuv.
Given an input graph G(V  E  C)  muSSP Ô¨Årst removes unnecessary edges in the graph cleaning
module. Then an initial shortest path tree (TSP) is obtained. If the stopping criteria is not met  muSSP
sends a unit Ô¨Çow from s to t along the shortest s-t path in the graph (AugmentFlow). The stopping
criteria is deÔ¨Åned in the same ways as the SSP algorithm in [16]. The multi-path Ô¨Ånding module
tries to Ô¨Ånd extra s-t paths on which we can send Ô¨Çow without updating the residual graph and
shortest path distances (FindMultiPath). If it succeeds  we can directly obtain the next s-t shortest
path (ExtractPath). Otherwise  the residual graph is updated based on the s-t path found above
(ResidualGraph). Edges in residual graph that are proved to be never involved in future shortest s-t
paths are clipped (ClipPermanentEdge). The algorithm then updates the shortest path tree and a
new s-t path is extracted.

3

Figure 2: (a) muSSP algorithm. The four modules/strategies are shown with different shaded colors.
(b) Flowchart of muSSP. Each module has the same color as (a). (c) Graph cleaning module for
dummy edge removal. The blue arc between h1 and o5 are thicker as it has larger arc cost. If
C(h1  o5) > C(s  o5) + C(h1  t)  arc (h1  o5) will be removed.

In the initialization step  we use topological sorting to Ô¨Ånd shortest path (DAG-SP). As the graph
contains negative-cost edges  we convert the edge cost to reduced cost as C d(u  v) = C(u  v) +
d(u) ‚àí d(v) (ConvertEdgeCost)  where d(v) is the cost of the shortest path from source node s to v.
The shortest paths found with the reduced cost can be proved to be the same as before [1]. The new
edge costs are non-negative and Dijkstra‚Äôs algorithm can be applied.

3.2 The independent Ô¨Çipping lemma

We present a lemma that plays an important role in the muSSP algorithm. Since each time we push a
unit Ô¨Çow in a unit-capacity residual graph  the residual graph can be updated by Ô¨Çipping the direction
of arcs on the path though which we push Ô¨Çow. The costs of those Ô¨Çipped arcs have the same absolute
values as the original ones but have the opposite signs. We denote the set of all simple paths in G
from u to v as Œ†G(u  v). Œ†‚àó
G(u  v) is the set of all simple least-cost paths in G from u to v. The
corresponding least cost is denoted as d‚àó
u(v). Tree is a special type of graph. If tree T is rooted at v0 
œÄT (v0  vi) is uniquely determined and we replace it with œÄT (vi). A tree T (V (cid:48)  E(cid:48)  C) is embedded
in graph G(V  E  C) if V (cid:48) ‚äÜ V   E(cid:48) ‚äÜ E.
DeÔ¨Ånition 2. A single-source shortest path tree (SP) is a tree T (V (cid:48)  E(cid:48)  C) embedded in a graph
G(V  E  C)  rooted at node s  such that œÄT (v) ‚àà Œ†‚àó
Examples of SP are shown in Fig. 3(a c e). Searching for the shortest s-t path can be done by
maintaining an SP and dynamically updating it when changes in the graph happen. To update the
SP in a changed graph  we (1) identify the nodes whose lowest-cost paths in the SP no longer exist
in the new graph; (2) update their least-cost paths from s in the new graph and rebuild SP.
DeÔ¨Ånition 3. Given a tree T (V (cid:48)  E(cid:48)  C) rooted at v0  we deÔ¨Åne the branch node and the set
of descendant nodes for a node v ‚àà V (cid:48): branch(v) = u ‚àà V (cid:48) such that (v0  u) ‚àà œÄT (v);
descendants(v) = {u ‚àà V (cid:48)|‚àÉvx ‚àà V (cid:48)  (v  vx) ‚àà œÄT (u)}.

G(s  v) for all v reachable from s in G.

4

(b)(c)tsùê∂(ùë† ùëúÔøΩ)ùê∂(‚ÑéÔøΩ ùë°)ùê∂(‚ÑéÔøΩ ùëúÔøΩ)7867864534532121(a)FlowpushingandmultipathfindingResidualgraphupdating/clippingShortestpathupdatingGraphcleaningInitializationExtractpathGraphFlowùëìSection3.3Section3.4Section3.6Section3.5Costdecreases?Multi-Path?YYNNFigure 3: (a) A single source shortest path tree (SP) shown with bold edges. The red path is the
shortest s-t path. (b) The shortest path in (a) is Ô¨Çipped (shown in green). (c) SP based on the updated
residual graph in (b). The red path is the new shortest path. The path through t makes the branch
containing the shortest s-t path large and we have more nodes to update. (d) Updated residual graph
with permanent edges clipped (red crosses). (e) With clipping  the branch containing the shortest path
is much smaller than (c). (f) Two branches in the SP  each containing a shortest s-t path (red and
purple). Only the red one connects to t in SP as it has a lower cost. We can push Ô¨Çows on both paths
without updating residual graph (Theorem 3). Post-nodes h8 and h6 are independent while h8 and h7
are not (Def. 4). (g) After removing permanent edges in the residual graph (b)  we need to update the
distances from s to the red nodes  because the shortest paths from s to these nodes no longer exist
due to the Ô¨Çipping operations. These nodes form a 0-tree. Note that edges in SP of (a) all have zero
costs. We initialize the distances from s to them using external edges (in blue) connecting to them.
For example  pre-node o5 is linked by arc (h1 o5) and (s o5)  so the initial distance is 2. Based on the
initial distance  only a subset of red nodes need to be pushed to the heap (Lemma 7) in Dijkstra‚Äôs
algorithm. Once a node is popped from the heap  we can batch update its descendants. For example 
if o5 is Ô¨Årstly popped  all its descendants will be assigned the same distance as o5 (Theorem 4).
Two branches are shown in Fig. 3(f). For a node v in an SP  its branch node is the second node in
path œÄT (v). Here we show that once the shortest s-t path is Ô¨Çipped and the residual graph is updated 
all nodes whose distances need to be updated share the same branch node.
DeÔ¨Ånition 4. In an SP  two nodes u and v are independent  if and only if branch(u) (cid:54)= branch(v).
Lemma 1 (Independent Ô¨Çipping). Given a residual graph Gr(Vr  Er  Cr) and its SP denoted as T
r  for node v ‚àà Vr that is independent
rooted at s  if we Ô¨Çip all edges in path œÄT (t) and get new graph G(cid:48)
with node t in T   its least-cost path œÄT (v) is still valid in the new graph  i.e.  œÄT (v) ‚àà Œ†‚àó
G(cid:48)
Lemma 1 shows that when we Ô¨Çip the shortest path œÄ = {(s  v0)  (v0  v1)  . . .   (vx  t)}  only the
nodes whose branch node is v0 need update. Reducing the size of descendants(v0) directly helps to
improve the efÔ¨Åciency. The Ô¨Årst two edge clipping strategies we proposed are to fulÔ¨Åll this task.

(s  v).

r

3.3 Graph cleaning with dummy edge clipping
Given a min-cost Ô¨Çow graph G(V  E  C) for MOT problem  an edge (u  v) ‚àà E connecting a post-
node to a pre-node is deÔ¨Åned as a dummy edge if C(u  v) > C(s  v) + C(u  t) (Fig. 2(c))  In graph
cleaning module  this kind of edges are removed to reduce the graph size and the computational cost
(ClipDummyEdge). Linkage between dissimilar objects tends to be a dummy edge. Therefore  we
hypothesize this linkage will not be included in a path  which is proved in the lemma below:

5

(a)(b)(c)(d)(e)WithoutclippingWithclipping7867864534532121ts786786453453211ts2Residualgraphupdating:permanentedgeclipping7867864534532121ts78678653532121ts44767643453211s58t827867864534532121tsBranch1Branch2Shortestpathinbranch1Shortestpathinbranch2(g)(f)76786453453211tsùë£ÔøΩ8200000000000000000235343Multi-pathfindingShortestpathtreeupdatingLemma 2. No dummy edges will appear in any optimal solution.

From lemma 2  we can immediately get the following theorem.
Theorem 1. Given a graph G(V  E  C) for MOT  removing all its dummy edges does not inÔ¨Çuence
the optimality of the Ô¨Ånal solution.

3.4 Residual graph with permanent edge clipping

After the step of updating the residual graph in each iteration  nodes tend to quickly accumulate to
the same branch especially when the graph is sparse (Fig. 3(a b c)). The main reason is that after
Ô¨Çipping paths  the least-cost path from s to some nodes goes through the sink node t. However  we
will prove that paths from t to other nodes will never be part of a valid s-t shortest path. Therefore  all
paths that go through t will be replaced by other paths in future iterations. Thus  the updates of those
nodes should not consider the arc originating from t. Here we theoretically prove our observation
and propose a way to diminish the effects of node accumulation in branches (Fig. 3(d e)). This is the
key step (ClipPermanentEdge) in our residual graph updating module.
DeÔ¨Ånition 5. Given a residual graph Gr(Vr  Er  Cr) in MOT  we deÔ¨Åne the set of permanent edges
as {(u  v) ‚àà Er|v = s OR u = t}.
Now we show the permanent edges are not necessary in Ô¨Ånding a shortest path.
Lemma 3. Any s-t path with permanent edge is not a simple path.
Lemma 4. Given a residual graph  we can always Ô¨Ånd a shortest s-t path which is also a simple path 
unless t cannot be reached from s.

The above two lemmas imply that we can always Ô¨Ånd a shortest s-t path with no permanent edges.
Theorem 2. Given a residual graph Gr(Vr  Er  Cr)  removing all its permanent edges does not
inÔ¨Çuence the optimality of the Ô¨Ånal solution.

When the Ô¨Çow amount is 0  we have no permanent edge. Each time we instantiate a shortest s-t
path and Ô¨Çip the arcs on it  we create two permanent edges. From the above theorem  these two
edges can be safely removed from current residual graph (Fig. 3(d)). Other than s and t  the nodes
related to permanent edges can also be removed from the graph  but its contribution to the efÔ¨Åciency
improvement is quite limited compared with edge clipping.

3.5 Multi-path Ô¨Ånding and Ô¨Çipping
Denote the sequentially instantiated shortest paths as {œÄ1  œÄ2  . . .   œÄK}. We observe that the SP in
the ith iteration may contain not only œÄi  but also the following shortest paths œÄi+1  œÄi+2  . . .  with
only t missed in them (Fig.3(f)). Simultaneously instantiating and Ô¨Çipping all these shortest paths
will save the computation on converting edge costs and decrease the number of duplicated updates 
because some nodes may be updated several times if we instantiate the shortest paths one by one (Fig.
3(f)).
Here we analogize the idea of A* algorithm and propose an efÔ¨Åcient way to check if current SP can
instantiate more than one shortest path. For each node v in graph G(V  E  C)  we deÔ¨Åne a distance
function dt(v)  whose value is C(v  t) if (v  t) ‚àà E and ‚àû otherwise. Though dt is not an admissible
search heuristic as commonly used in A* algorithm  we can still Ô¨Ånd the shortest s-t path based on it:
Lemma 5. Given a residual graph Gr(Vr  Er  Cr)  its SP rooted at s  and the shortest distance
function d from s to each node  we have d(t) = min(d(v) + dt(v))  v ‚àà Vr \ {t}.
Theorem 3. Given a residual graph Gr(Vr  Er  Cr)  its SP denoted as T (V (cid:48)
r  Cr) rooted
at s and a sorted list of {d(v) + dt(v)} with v ‚àà Vr with ascending order  if the k nodes
{v1  v2  . . .   vk} that occupy the top k locations of the list are mutually independent  the k paths
{œÄT (v1)  œÄT (v2)  . . .   œÄT (vk)} can be simultaneously instantiated as k shortest paths.
Based on theorem 3  we can efÔ¨Åciently check whether we can instantiate multiple paths from current
SP. This is achieved by function FindMultiPath given the information of the branches to be updated
(IdentifyNode4Update). An example of multi-path Ô¨Çipping is shown in Fig. 3(f).

r   E(cid:48)

6

3.6 Batch updating and heap shrinking for shortest path tree

In the shortest path tree updating module  we will discuss two approaches that reduce the running time
of Dijkstra‚Äôs algorithm (DijkstraWithBatchProc). The Ô¨Årst is to simultaneously update the distances
of multiple nodes. The second is to push less nodes into the heap used in Dijkstra‚Äôs algorithm.
If a tree has zero cost for all edges  we call it a 0-tree (Fig. 3(g)). A 0-tree can emerge after edge
cost conversion and Ô¨Çipping. We can utilize 0-tree to reduce the computational cost of updating
distances of nodes in each iteration. After identifying the nodes that must be updated for Ô¨Ånding the
next shortest s-t path  we can fulÔ¨Åll this task using Dijkstra‚Äôs algorithm  as the edge costs have been
converted to non-negative values. Given G and its SP denoted as T rooted at s  after conversion  T
becomes not only an SP but also a 0-tree. This property can help to accelerate Dijkstra‚Äôs algorithm.
For clarity and simplicity  we assume the updating happens with only one path Ô¨Çipped as is shown in
Fig.3(d). The condition of updating nodes after simultaneously Ô¨Çipping multiple paths is the same.
Suppose shortest s-t path to be Ô¨Çipped in current iteration is œÄ = {(s  v0)  (v0  v1)  . . .   (vx  t)}.
Since the SP is a 0-tree now  after Ô¨Çipping and permanent edge clipping  the nodes to update can be
divided into two sets: {t} and another 0-tree rooted at vx (Fig. 3(g)). As t can be efÔ¨Åciently updated
by the sorted list discussed in Theorem 3  here we only show how to update nodes in the 0-tree rooted
at vx.
Lemma 6. Given a 0-tree T0(V0  E0  Cr) embedded in residual graph Gr(Vr  Er  Cr)  if v ‚àà
descendants(v0)  d‚àó
Lemma 6 shows that for a node in the 0-tree  the shortest distance from s to its descendants nodes
is smaller than or equal to the distance from s to itself. Besides  Dijkstra‚Äôs algorithm always Ô¨Årst
deals with node with shorter distances from s. Combining these two facts leads to our batch updating
strategy below.
Theorem 4. In Dijkstra‚Äôs algorithm  if the distance from s to a node v in a 0-tree is permanently
labeled as d(v)  d(v) is also the permanent label for the nodes in descendants(v) that haven‚Äôt been
permanently labeled.

u(v0)  ‚àÄu ‚àà Vr ‚àÄv0 ‚àà V0.

u(v) ‚â§ d‚àó

It shows that we can permanently label a batch of nodes each time in Dijkstra‚Äôs algorithm (Fig. 3(g)).
Dijkstra‚Äôs algorithm is commonly implemented with heap. Decreasing the heap size saves the time
consumption of popping/pushing operation on it and increases efÔ¨Åciency. Inspired by the idea in [17]
for dSSSP  we found the heap size can also be shrunk based on Lemma 6.
The way we update the 0-tree rooted at vx with Dijkstra‚Äôs algorithm is to relax all the edges that link
nodes outside the 0-tree to nodes inside it. Then push their temporary distances to the heap. Thus the
initial size of the heap will be the node number of the tree. We divide the nodes in the 0-tree into two
sets: P and Q. Set P contains nodes that cannot be correctly updated without checking the other
nodes in the 0-tree and set Q is the complementary set of P . Only nodes in Q need to be inserted to
the heap. We propose an efÔ¨Åcient way to estimate the set of P and only need to insert the remaining
nodes in the 0-tree into the heap.
Lemma 7. In a 0-tree  nodes with larger temporary distance labels than their parent belong to set P .

From Lemma 7  we can use a breadth-Ô¨Årst search starting from root (vx) of the 0-tree  pushing only
nodes whose temporary distance labels are not larger than their parents in the 0-tree (Fig. 3(g)). In
the best case  the heap size could be 0 and updating of the 0-tree takes linear-time.

4 Experiments

We conducted three sets of experiments for the detailed analysis of efÔ¨Åciency improvement. First 
muSSP is used to directly solve min-cost Ô¨Çow based data association problems in MOT. Second 
we test the efÔ¨Åciency of muSSP as a sub-routine to iteratively approximate the quadratic program-
ming formulation in MOT. Third  to further understand the improvement  we examine the relative
contributions of each key strategy we proposed  which can be found in the supplementary.
We compared muSSP with three popular methods  SSP  FollowMe [14]  and cs2 [12]. Written in C
language  cs2 is an efÔ¨Åcient implementation of cost-scaling algorithm  which is widely considered
as the best solver for generic min-cost Ô¨Çow problems and was used in [21  16] for MOT problems.

7

Datasets

Table 1: EfÔ¨Åciency comparison on MOT datasets (in seconds)
KITTI(reglets)
seq11

KITTI(DPM)
seq11

seq00

seq14

seq10

seq00

seq10

18.4(108)
3.4(20)
11.8(70)
0.17(1)

(a) graph design from [16]
SSP
FollowMe
cs2
muSSP
(b) graph design from [14]
SSP
FollowMe
cs2
muSSP
(c) graph design from [19]
1.2h(24.5k)
SSP
917.9(5.1k)
FollowMe
24.6(137)
cs2
0.18(1)
muSSP
Datasets

20.9(116)
3.2(18)
13.6(76)
0.18(1)

seq04

(a) graph design from [16]
1.8h(4.9k)
SSP
2.4h(6.5k)
FollowMe
441.3(337)
cs2
1.31(1)
muSSP
(b) graph design from [14]
SSP
FollowMe
cs2
muSSP

1.6h(4.3k)
2.3h(6.2k)
137.2(103)
1.33(1)

142.8(269)
12.7(24)
88.4(167)
0.53(1)

266.9(523)
34.4(67)
98.6(193)
0.51(1)

68.0(200)
6.4(19)
42.6(125)
0.34(1)

77.9(223)
9.6(28)
45.1(129)
0.35(1)

10.0h(46.2k)
3.7h(16.9k)
184.3(236)
0.78(1)

4.5h(26.0k)
1.0h(5.5k)
78.7(127)
0.62(1)

CVPR19

seq07

seq06

370.9(976)
801.1(2.1k)
73.7(194)
0.38(1)

513.7(1.3k)
803.3(2.0k)
35.7(87)
0.41(1)

23.5(235)
43.4(434)
16.2(162)
0.10(1)

21.2(236)
36.2(402)
6.7(74)
0.09(1)

136.2(619)
220.6(1.0k)
34.5(157)
0.22(1)

85.7(204)
21.2(50)
39.4(94)
0.42(1)

38.5(167)
62.1(270)
16.0(70)
0.23(1)

183.9(400)
53.1(115)
63.1(137)
0.46(1)

173.0(455)
26.2(69)
46.1(121)
0.38(1)

137.3(490)
36.8(131)
57.8(206)
0.28(1)

120.8(448)
12.0(44)
41.1(152)
0.27(1)

96.1(291)
12.0(36)
39.8(121)
0.33(1)

5.2h(37.6k)
0.9h(6.7k)
69.7(139)
0.50(1)

seq08

6.2(89)
1.4(20)
4.3(61)
0.07(1)

9.4(117)
3.8(48)
5.0(63)
0.08(1)

9.1(129)
1.8(26)
7.2(103)
0.07(1)

12.8(160)
3.1(39)
6.0(75)
0.08(1)

9.4(156)
1.5(25)
5.7(95)
0.06(1)

18.1(227)
5.9(74)
6.3(78)
0.08(1)

437.6(4.4k)
198.4(2.0k)
5.9(59)
0.10(1)

235.8(1.6k)
224.5(1.5k)
8.5(57)
0.15(1)

ETHZ(DPM)
seq04

seq03

seq14

31.8(245)
6.4(49)
10.3(79)
0.13(1)

54.7(421)
15.3(118)
8.9(69)
0.13(1)

246.8(1.8k)
242.2(1.7k)
7.7(55)
0.14(1)

605.9(3.0k)
649.1(3.2k)
12.8(64)
0.20(1)

PTC

Mid

High
(d) probability principled
379.2(134)
0.4h(106)
0.3h(430)
1.2h(339)
20.2(7)
71.5(5)
13.10(1)
2.82(1)

Low

10.7(41)
40.4(155)
3.0(12)
0.25(1)

SSP and our muSSP were implemented in C++. To perform a fair comparison  FollowMe was
re-implemented from their python package in C++. The implementation details can be found in the
supplementary.

4.1 Solving the direct min-cost Ô¨Çow model of data association problems in MOT
To represent the wide range of real world applications  we selected four public datasets including
three natural image MOT datasets (ETHZ (BAHNHOF and JELMOLI) [8]  KITTI-Car [11]  MOT
CVPR 2019 Challenge[6]) and one particle tracking dataset (ISBI12 Particle Tracking Challenge
(PTC) [5]). For natural image MOT  we designed the graphs using three methods [16  14  19]. The
difference among them is how to measure the similarity between detections and thus leads to different
arc cost functions in the graphs. As [19] is speciÔ¨Åcally designed for road scene  it was only applied to
KITTI-Car dataset. For particle tracking  we used a probability principled way to design the graph 
as detailed in supplementary.
All the experiments were based on the detection results either included in the datasets or provided by
the authors of [16  14  19]. The number of the detections varies from ‚àº7k to ‚àº200k. We performed
experiments with 39 combinations of detection results  graph design methods  and datasets. Summary
of the detected objects  frames and the vertices and edges of the resultant graphs can be found in the
supplementary.
Table 1 records the computation time for all experiments on a single core of 2.40GHz Xeon(R) CPU
E5-2630. Each cell of the table represents the time consumed by a speciÔ¨Åc method under a graph
design. The time was reported in seconds and sometimes in hours as denoted by the appending letter
‚Äôh‚Äô. The numbers in the brackets indicate how many folds the method is slower than the most efÔ¨Åcient
one. Bold font indicates the most efÔ¨Åcient method. Overall  muSSP is always the fastest method
in all 39 experiments. For majority of the experiments  muSSP achieved sub-second performance 
while peer methods need up to several hours. Averagely muSSP is 4193 times faster than SSP  1630
times faster than FollowMe and 111 times faster than cs2. It can be seen from the table that SSP
and FollowMe vary greatly with different graph settings from seconds to several hours. Interestingly 
as an improved version of SSP  FollowMe usually performs better than SSP but when the object
number is large (e.g.  CVPR19)  its performance drops quickly and is even worse than SSP. This
is because FollowMe does not explicitly know that whether the paths containing Ô¨Çipped edge(s) in
current residual graph are all valid in updating the shortest path tree (Lemma 1). To make sure not to
miss those valid ones  FollowMe inserts the nodes incident to the Ô¨Çipped edges to the heap used in
Dijkstra‚Äôs algorithm Ô¨Årst. This operation will make the heap size huge when we have a large number

8

of paths Ô¨Çipped. Our experiment on heap shrinking strategy in supplementary clearly shows this.
cs2 performs relatively stable and outperforms SSP and FollowMe when the number of objects is
large. It is likely that the local updating strategy of cs2 scales better with graph size than SSP and
FollowMe. Note that the tracking results comparison is not listed since the solutions obtained by our
proposed approach and baseline approaches are the same. This is also true for the following quadratic
programming problem where the initialization and step function in Frank-Wolfe algorithm are the
same for each method.

4.2 Solving the min-cost Ô¨Çow approximation to the high-order modeling in MOT

High-order relationships between detected objects have been incorporated for more accurate tracking 
which  however  leads to NP-hard problems [4  13  3]. Existing methods approximate the solution
with the help of Frank-Wolfe algorithm or Lagrangian relaxation  where min-cost Ô¨Çow solvers were
frequently used as a sub-routine. Here we test the efÔ¨Åciency of our muSSP in approximating the
solution of a quadratic programming problem formulated in [4] for the tracking problem. The
quadratic objective function is provided by the authors in their software package derived from the
sequence ‚ÄôTime_13-59/View_002‚Äô of dataset PETS09 S1.L1 [9]. We Ô¨Årstly relax its integer solution
constraint and then use Frank-Wolfe algorithm to iteratively solve this quadratic programming
problem. In each iteration  the problem is reduced to a min-cost Ô¨Çow problem. The graph has 5866
vertices and 36688 edges  and the algorithm runs totally 400 iterations. Results are shown in Table 2.
muSSP is 19 times faster than SSP  27 times faster than FollowMe and 30 times faster than cs2.

Table 2: EfÔ¨Åciency comparison of solving quadratic programming problem

FollowMe
557.0(27)

cs2

613.1(30)

Method
PETS S1.L1-2

SSP

391.9(19)

muSSP
20.3(1)

5 Conclusion

In this paper  we proposed an efÔ¨Åcient yet exact min-cost Ô¨Çow solver muSSP for the data association
in MOT problems  taking advantage of the specialties of the graphs built in MOT problems. muSSP is
applicable not only to the direct min-cost Ô¨Çow modeling but also to the min-cost Ô¨Çow approximation
to the high-order modeling in MOT. The efÔ¨Åciency was demonstrated on a wide range of public
datasets combined with various object detection results and graph designs. We expect this large
degree of efÔ¨Åciency improvement will save computational time for existing applications  enable
engineers to tackle larger scale of problems  and inspire researchers to build more accurate modeling
for tracking  for instance  reÔ¨Åning iteratively the graph designs based on the tracking results.

References
[1] Ravindra K Ahuja  Thomas L Magnanti  and James B Orlin. Network Ô¨Çows: Theory  algorithms 

and applications. 2008.

[2] Jerome Berclaz  Francois Fleuret  Engin Turetken  and Pascal Fua. Multiple object tracking
IEEE transactions on pattern analysis and machine

using k-shortest paths optimization.
intelligence  33(9):1806‚Äì1819  2011.

[3] Asad A Butt and Robert T Collins. Multi-target tracking by lagrangian relaxation to min-
cost network Ô¨Çow. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition  pages 1846‚Äì1853  2013.

[4] Visesh Chari  Simon Lacoste-Julien  Ivan Laptev  and Josef Sivic. On pairwise costs for network
Ô¨Çow multi-object tracking. In Proceedings of the IEEE Conference on Computer Vision and
Pattern Recognition  pages 5537‚Äì5545  2015.

[5] Nicolas Chenouard  Ihor Smal  Fabrice De Chaumont  Martin Ma≈°ka  Ivo F Sbalzarini  Yuanhao
Gong  Janick Cardinale  Craig Carthel  Stefano Coraluppi  Mark Winter  et al. Objective
comparison of particle tracking methods. Nature methods  11(3):281  2014.

9

[6] Patrick Dendorfer  Hamid RezatoÔ¨Åghi  Anton Milan  Javen Shi  Daniel Cremers  Ian Reid 
Stefan Roth  Konrad Schindler  and Laura Leal-Taixe. Cvpr19 tracking and detection challenge:
How crowded can it get?  2019.

[7] Patrick Emami  Panos M Pardalos  Lily Elefteriadou  and Sanjay Ranka. Machine learning meth-
ods for solving assignment problems in multi-target tracking. arXiv preprint arXiv:1802.06897 
2018.

[8] A. Ess  B. Leibe  K. Schindler    and L. van Gool. A mobile vision system for robust multi-
person tracking. In IEEE Conference on Computer Vision and Pattern Recognition (CVPR‚Äô08).
IEEE Press  June 2008.

[9] James Ferryman and Ali Shahrokni. Pets2009: Dataset and challenge. In 2009 Twelfth IEEE
International Workshop on Performance Evaluation of Tracking and Surveillance  pages 1‚Äì6.
IEEE  2009.

[10] Daniele Frigioni  Alberto Marchetti-Spaccamela  and Umberto Nanni. Fully dynamic algorithms

for maintaining shortest paths trees. Journal of Algorithms  34(2):251‚Äì281  2000.

[11] Andreas Geiger  Philip Lenz  and Raquel Urtasun. Are we ready for autonomous driving?
the kitti vision benchmark suite. In 2012 IEEE Conference on Computer Vision and Pattern
Recognition  pages 3354‚Äì3361. IEEE  2012.

[12] Andrew V Goldberg. An efÔ¨Åcient implementation of a scaling minimum-cost Ô¨Çow algorithm.

Journal of algorithms  22(1):1‚Äì29  1997.

[13] Roberto Henschel  Laura Leal-Taix√©  Daniel Cremers  and Bodo Rosenhahn. Fusion of head
and full-body detectors for multi-object tracking. In Proceedings of the IEEE Conference on
Computer Vision and Pattern Recognition Workshops  pages 1428‚Äì1437  2018.

[14] Philip Lenz  Andreas Geiger  and Raquel Urtasun. Followme: EfÔ¨Åcient online min-cost Ô¨Çow
tracking with bounded memory and computation. In Proceedings of the IEEE International
Conference on Computer Vision  pages 4364‚Äì4372  2015.

[15] Wenhan Luo  Junliang Xing  Anton Milan  Xiaoqin Zhang  Wei Liu  Xiaowei Zhao  and Tae-
Kyun Kim. Multiple object tracking: A literature review. arXiv preprint arXiv:1409.7618 
2014.

[16] Hamed Pirsiavash  Deva Ramanan  and Charless C Fowlkes. Globally-optimal greedy algorithms

for tracking a variable number of objects. In CVPR 2011  pages 1201‚Äì1208. IEEE  2011.

[17] Ganesan Ramalingam and Thomas Reps. An incremental algorithm for a generalization of the

shortest-path problem. Journal of Algorithms  21(2):267‚Äì305  1996.

[18] Liam Roditty and Uri Zwick. On dynamic shortest paths problems. In European Symposium on

Algorithms  pages 580‚Äì591. Springer  2004.

[19] Sarthak Sharma  Junaid Ahmed Ansari  J Krishna Murthy  and K Madhava Krishna. Beyond
pixels: Leveraging geometry and shape cues for online multi-object tracking. In 2018 IEEE
International Conference on Robotics and Automation (ICRA)  pages 3508‚Äì3515. IEEE  2018.

[20] Yi Wu  Jongwoo Lim  and Ming-Hsuan Yang. Online object tracking: A benchmark. In
Proceedings of the IEEE conference on computer vision and pattern recognition  pages 2411‚Äì
2418  2013.

[21] Li Zhang  Yuan Li  and Ramakant Nevatia. Global data association for multi-object tracking
using network Ô¨Çows. In 2008 IEEE Conference on Computer Vision and Pattern Recognition 
pages 1‚Äì8. IEEE  2008.

10

,Congchao Wang
Yizhi Wang
Yinxue Wang
Chiung-Ting Wu
Guoqiang Yu